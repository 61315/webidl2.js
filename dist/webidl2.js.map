{"version":3,"sources":["webpack://WebIDL2/webpack/universalModuleDefinition","webpack://WebIDL2/webpack/bootstrap","webpack://WebIDL2/./lib/productions/helpers.js","webpack://WebIDL2/./lib/error.js","webpack://WebIDL2/./lib/tokeniser.js","webpack://WebIDL2/./lib/productions/array-base.js","webpack://WebIDL2/./lib/productions/base.js","webpack://WebIDL2/./lib/productions/token.js","webpack://WebIDL2/./lib/productions/default.js","webpack://WebIDL2/./lib/productions/enum.js","webpack://WebIDL2/./lib/productions/includes.js","webpack://WebIDL2/./lib/webidl2.js","webpack://WebIDL2/./lib/writer.js","webpack://WebIDL2/./lib/validator.js","webpack://WebIDL2/./index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","helpers_unescape","identifier","startsWith","slice","list","tokeniser","parser","allowDangler","listName","first","tokens","separator","consume","items","item","error","push","const_value","const_data","type","negative","error_error","source","position","current","message","sliceTokens","count","Math","max","tokensToText","inputs","precedes","text","map","trivia","join","nextToken","length","line","precedingLine","splitted","split","lastLine","subsequentTokens","subsequentText","contextualMessage","repeat","partial","input","validationError","token","index","tokenRe","decimal","integer","string","whitespace","comment","other","stringTypes","argumentNameKeywords","nonRegexTerminals","concat","punctuations","tokeniser_Tokeniser","[object Object]","idl","str","lastCharIndex","nextChar","charAt","result","test","attemptTokenMatch","noFlushTrivia","currentTrivia","pop","match","includes","punctuation","Error","re","lastIndex","exec","tokenise","WebIDLParseError","syntaxError","candidates","probe","super","ArrayBase","Array","defineProperties","Base","json","undefined","inheritance","proto","descMap","getOwnPropertyDescriptors","entries","getPrototypeOf","token_Token","default_Default","assign","def","expression","close","enum_EnumValue","enum_Enum","base","ret","open","values","parse","termination","includes_Includes","target","mixin","unconsume","parseByTokens","options","DECIMAL","INT","ID","STR","primitive_type","num_type","prefix","postfix","Type","integer_type","float_type","type_suffix","obj","nullable","extAttrs","generic","union","idlType","subtype","filter","GenericType","typeName","return_type","type_with_extended_attributes","keyType","keyIdlType","valueType","UnionType","typ","or","single_type","ExtendedAttributes","Argument","start_position","optional","variadic","default","argument_list","ExtendedAttributeParameters","secondaryName","rhsType","ids","identifiers","hasRhs","SimpleExtendedAttribute","params","rhs","arguments","Constant","CallbackFunction","Attribute","special","noInherit","readonly","voidToken","Operation","regular","static_member","stringifier","IterableLike","secondTypeRequired","secondTypeAllowed","Container","instance","inheritable","allowedMembers","colon","members","ea","mem","args","Interface","callback","Mixin","interface_","opts","Namespace","Dictionary","Field","required","Typedef","definition","tok","res","defs","eof","concrete","definitions","noop","arg","templates","wrap","reference","extendedAttribute","extendedAttributeReference","write","ast","ts","raw","unescaped","context","wrapper","reference_token","name_token","type_body","it","firstToken","ref","extended_attributes","default_","argument","data","make_ext_at","id","eats","container","inh","iterate","iterable_like","parent","table","interface","interface mixin","namespace","operation","body","attribute","dictionary","field","const","typedef","enum","enum-value","v","iterable","legacyiterable","maplike","setlike","callback interface","things","results","thing","dispatch","checkDuplicatedNames","unique","duplicates","dup","checkInterfaceMemberDuplication","interfaces","includesMap","Map","all","include","array","set","getIncludesMap","forEachInterface","opNames","Set","getOperations","op","partials","mixins","ext","additions","forEachExtension","addition","add","existings","has","validate","groupDefinitions","__webpack_exports__"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,GAAAH,GACA,iBAAAC,QACAA,QAAA,QAAAD,IAEAD,EAAA,QAAAC,IARA,CASCK,KAAA,WACD,mBCTA,IAAAC,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,GAAA,CACAC,EAAAD,EACAE,GAAA,EACAT,QAAA,IAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,kCC/EO,SAASC,EAAQC,GACxB,OAAAA,EAAAC,WAAA,KAAAD,EAAAE,MAAA,GAAAF,EAWO,SAAAG,EAAAC,GAAAC,OAA0BA,EAAAC,eAAAC,WAAA,SACjC,MAAAC,EAAAH,EAAAD,GACA,IAAAI,EACA,SAEAA,EAAAC,OAAAC,UAAAN,EAAAO,QAAA,KACA,MAAAC,EAAA,CAAAJ,GACA,KAAAA,EAAAC,OAAAC,WAAA,CACA,MAAAG,EAAAR,EAAAD,GACA,IAAAS,EAAA,CACAP,GACAF,EAAAU,2BAA6CP,KAE7C,MAIA,GAFAM,EAAAJ,OAAAC,UAAAN,EAAAO,QAAA,KACAC,EAAAG,KAAAF,IACAA,EAAAJ,OAAAC,UAAA,MAEA,OAAAE,EAMO,SAAAI,EAAAZ,GACP,OAAAA,EAAAO,QAAA,iEAQO,SAAAM,GAAAC,KAAqBA,EAAAlC,UAC5B,OAAAkC,GACA,WACA,YACA,OAAcA,KAAA,UAAAlC,MAAA,SAAAkC,GACd,eACA,gBACA,OAAcA,KAAA,WAAAC,SAAAD,EAAAjB,WAAA,MACd,QACA,OAAciB,KAAA,WAAAlC,MAAA,IACd,cACA,cACA,OAAgBkC,KAAA,SAAAlC,SAChB,aACA,OAAckC,KAAA,SAAAlC,QAAAkB,MAAA,OACd,QACA,OAAcgB,SCrDd,SAASE,EAAKC,EAAAC,EAAAC,EAAAC,EAAAN,GAId,SAAAO,EAAAC,GACA,OAAAA,EAAA,EACAL,EAAAnB,MAAAoB,IAAAI,GACAL,EAAAnB,MAAAyB,KAAAC,IAAAN,EAAAI,EAAA,GAAAJ,GAGA,SAAAO,EAAAC,GAAAC,SAAiCA,GAAW,IAC5C,MAAAC,EAAAF,EAAAG,IAAAhD,KAAAiD,OAAAjD,EAAAD,OAAAmD,KAAA,IACAC,EAAAf,EAAAC,GACA,cAAAc,EAAAlB,KACAc,EAEAD,EACAC,EAAAI,EAAAF,OAEAF,EAAA9B,MAAAkC,EAAAF,OAAAG,QAGA,MACAC,EACA,QAAAjB,EAAAC,GAAAJ,KAAAG,EAAAC,GAAAgB,KACAjB,EAAAgB,OAAA,EAAAhB,EAAAC,EAAA,GAAAgB,KACA,EAEAC,EArCA,SAAAP,GACA,MAAAQ,EAAAR,EAAAS,MAAA,MACA,OAAAD,IAAAH,OAAA,GAmCAK,CACAb,EAAAJ,GAPA,GAOA,CAA2CM,UAAA,KAG3CY,EAAAlB,EAVA,GAWAmB,EAAAf,EAAAc,GAIAE,EAAAN,EAHAK,EAAAH,MAAA,SAGA,MADA,IAAAK,OAAAP,EAAAF,QAAA,KAAAb,GAKA,OACAA,WAAgBN,mBAAsBoB,IAFtCf,OADA,WAAAL,EAAA,sBAC6DK,EAAAwB,QAAA,gBAAoCxB,EAAAL,QAAgBK,EAAAjD,SAAa,QAEzDuE,IACrEP,OACAU,MAAAJ,EACAnC,OAAAkC,GAcO,SAAAM,EAAA5B,EAAA6B,EAAA3B,EAAAC,GACP,OAASJ,EAAKC,EAAA6B,EAAAC,MAAA5B,EAAAC,EAAA,cAAAA,eCpEd,MAAA4B,EAAA,CAGAC,QAAA,sGACAC,QAAA,8CACAtD,WAAA,+BACAuD,OAAA,WACAC,WAAA,cACAC,QAAA,iDACAC,MAAA,wBAGOC,EAAA,CACP,aACA,YACA,aAGOC,EAAA,CACP,YACA,WACA,QACA,UACA,aACA,OACA,SACA,WACA,UACA,YACA,WACA,UACA,YACA,UACA,WACA,UACA,SACA,SACA,cACA,UACA,gBAGAC,EAAA,CACA,YACA,cACA,WACA,MACA,UACA,UACA,OACA,SACA,QACA,QACA,aACA,iBACA,OACA,QACA,OACA,QACA,WACA,KACA,WACA,SACA,WACA,QACA,OACA,WACA,QACAC,OAAAF,EAAAD,GAEAI,EAAA,CACA,IACA,IACA,IACA,MACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KA6FO,MAAMC,EAIbC,YAAAC,GACAvG,KAAA0D,OA5FA,SAAA8C,GACA,MAAA1D,EAAA,GACA,IAAA2D,EAAA,EACAlC,EAAA,GACAI,EAAA,EACAa,EAAA,EACA,KAAAiB,EAAAD,EAAA9B,QAAA,CACA,MAAAgC,EAAAF,EAAAG,OAAAF,GACA,IAAAG,GAAA,EAQA,GANA,YAAAC,KAAAH,GACAE,EAAAE,EAAA,cAAgDC,eAAA,IAC3C,MAAAL,IACLE,EAAAE,EAAA,WAA6CC,eAAA,MAG7C,IAAAH,EAAA,CACA,MAAAI,EAAAlE,EAAAmE,MAAA5F,MACAsD,IAAAqC,EAAAE,MAAA,YAAAxC,OACAH,GAAAyC,EACAxB,GAAA,OACK,oBAAAqB,KAAAH,IAKL,IAHA,KADAE,EAAAE,EAAA,cAEAF,EAAAE,EAAA,aAEA,IAAAF,EAAA,CACAA,EAAAE,EAAA,cACA,MAAAvB,EAAAzC,IAAA4B,OAAA,IACA,IAAAkC,GAAAV,EAAAiB,SAAA5B,EAAAlE,SACAkE,EAAAhC,KAAAgC,EAAAlE,YAGK,MAAAqF,IACLE,EAAAE,EAAA,WAGA,UAAAM,KAAAhB,EACA,GAAAI,EAAAlE,WAAA8E,EAAAX,GAAA,CACA3D,EAAAM,KAAA,CAAqBG,KAAA6D,EAAA/F,MAAA+F,EAAA7C,SAAAI,OAAAa,UACrBjB,EAAA,GAEAqC,EADAH,GAAAW,EAAA1C,OAEA,MAQA,IAHA,IAAAkC,IACAA,EAAAE,EAAA,WAEA,IAAAF,EACA,UAAAS,MAAA,gCAEAZ,EAAAG,EACApB,GAAA,EAUA,OANA1C,EAAAM,KAAA,CACAG,KAAA,MACAlC,MAAA,GACAkD,WAGAzB,EAOA,SAAAgE,EAAAvD,GAAAwD,cAAoCA,GAAgB,IACpD,MAAAO,EAAA7B,EAAAlC,GACA+D,EAAAC,UAAAd,EACA,MAAAG,EAAAU,EAAAE,KAAAhB,GACA,OAAAI,GACA9D,EAAAM,KAAA,CAAmBG,OAAAlC,MAAAuF,EAAA,GAAArC,SAAAI,OAAAa,UACnBuB,IACAxC,EAAA,IAEA+C,EAAAC,YAEA,GASAE,CAAAlB,GACAvG,KAAA2D,SAAA,EAMA2C,MAAAzC,GACA,UAAA6D,EDlIO,SAAAhE,EAAAC,EAAAC,EAAAC,GACP,OAASJ,EAAKC,EAAAC,EAAAC,EAAAC,EAAA,UCiIiB8D,CAAW3H,KAAA0D,OAAA1D,KAAA2D,SAAA3D,KAAA4D,QAAAC,IAM1CyC,MAAA/C,GACA,OAAAvD,KAAA0D,OAAAgB,OAAA1E,KAAA2D,UAAA3D,KAAA0D,OAAA1D,KAAA2D,UAAAJ,SAMA+C,WAAAsB,GACA,UAAArE,KAAAqE,EAAA,CACA,IAAA5H,KAAA6H,MAAAtE,GAAA,SACA,MAAAgC,EAAAvF,KAAA0D,OAAA1D,KAAA2D,UAEA,OADA3D,KAAA2D,WACA4B,GAOAe,UAAA3C,GACA3D,KAAA2D,YAIA,MAAA+D,UAAAL,MACAf,aAAAzC,QAAeA,EAAAc,OAAAU,QAAAvC,WACfgF,MAAAjE,GACA7D,KAAAW,KAAA,mBACAX,KAAA2E,OACA3E,KAAAqF,QACArF,KAAA8C,UCtOO,MAAAiF,UAAAC,MACP1B,aAAA5C,OAAeA,EAAAZ,WACfgF,QACAhH,OAAAmH,iBAAAjI,KAAA,CACA0D,OAAA,CAAerC,MAAAqC,GACfZ,OAAA,CAAezB,MAAAyB,MCLR,MAAAoF,EACP5B,aAAA5C,OAAeA,EAAAZ,WACfhC,OAAAmH,iBAAAjI,KAAA,CACA0D,OAAA,CAAerC,MAAAqC,GACfZ,OAAA,CAAezB,MAAAyB,KAIfwD,SACA,MAAA6B,EAAA,CAAkB5E,UAAA6E,EAAAzH,UAAAyH,EAAAC,iBAAAD,GAClB,IAAAE,EAAAtI,KACA,KAAAsI,IAAAxH,OAAAkB,WAAA,CACA,MAAAuG,EAAAzH,OAAA0H,0BAAAF,GACA,UAAA3G,EAAAN,KAAAP,OAAA2H,QAAAF,IACAlH,EAAAL,YAAAK,EAAAJ,OACAkH,EAAAxG,GAAA3B,KAAA2B,IAGA2G,EAAAxH,OAAA4H,eAAAJ,GAEA,OAAAH,GClBO,MAAMQ,UAAcT,EAK3B5B,cAAA7D,EAAAc,GACA,WACA,MAAAlC,EAAAoB,EAAAO,QAAAO,GACA,GAAAlC,EACA,WAAmBsH,EAAK,CAAEjF,OAAAjB,EAAAiB,OAAAZ,OAAA,CAAoCzB,YAK9DA,YACA,OAAArB,KAAA8C,OAAAzB,aCdO,MAAMuH,UAAgBV,EAI7B5B,aAAA7D,GACA,MAAAoG,EAAApG,EAAAO,QAAA,KACA,IAAA6F,EACA,YAEA,MAAAC,EAAgBzF,EAAWZ,MAAAO,QAAA,sBAAAP,EAAAU,MAAA,wBAC3B4F,EAAA,CAAAD,GACA,SAAAA,EAAAvF,KAAA,CACA,MAAAyF,EAAAvG,EAAAO,QAAA,MAAAP,EAAAU,MAAA,wCACA4F,EAAA3F,KAAA4F,GAEA,WAAeJ,EAAO,CAAElF,OAAAjB,EAAAiB,OAAAZ,OAAA,CAAoC+F,UAASE,eAGrEzC,aAAA5C,OAAeA,EAAAZ,SAAAiG,eACfjB,MAAA,CAAWpE,SAAAZ,WACXhC,OAAAC,eAAAf,KAAA,cAA+CqB,MAAA0H,IAG/CxF,WACA,OAAWD,EAAUtD,KAAA+I,WAAA,IAAAxF,KAErBlC,YACA,OAAWiC,EAAUtD,KAAA+I,WAAA,IAAA1H,MAErBmC,eACA,OAAWF,EAAUtD,KAAA+I,WAAA,IAAAvF,UC7BrB,MAAMyF,UAAkBN,EAIxBrC,aAAA7D,GACA,MAAApB,EAAAoB,EAAAO,QAAA,UACA,GAAA3B,EACA,WAAiB4H,EAAS,CAAEvF,OAAAjB,EAAAiB,OAAAZ,OAAA,CAAoCzB,WAIhEkC,WACA,mBAEAlC,YACA,OAAAyG,MAAAzG,MAAAkB,MAAA,OAIO,MAAM2G,UAAahB,EAI1B5B,aAAA7D,GACA,MAAAK,EAAA,GAEA,GADAA,EAAAqG,KAAA1G,EAAAO,QAAA,SACAF,EAAAqG,KACA,OAEArG,EAAAnC,KAAA8B,EAAAO,QAAA,eAAAP,EAAAU,MAAA,oBACA,MAAAiG,EAAA3G,EAAAmB,QAAA,IAAwCsF,EAAI,CAAExF,OAAAjB,EAAAiB,OAAAZ,WAe9C,OAdAA,EAAAuG,KAAA5G,EAAAO,QAAA,MAAsCP,EAAAU,MAAA,iBACtCiG,EAAAE,OAAiB9G,EAAIC,EAAA,CACrBC,OAAcuG,EAASM,MACvB5G,cAAA,EACAC,SAAA,gBAEAH,EAAAoF,MAAA,WACApF,EAAAU,MAAA,gCAEAL,EAAAkG,MAAAvG,EAAAO,QAAA,MAAuCP,EAAAU,MAAA,4BACvCiG,EAAAE,OAAA5E,QACAjC,EAAAU,MAAA,oBAEAL,EAAA0G,YAAA/G,EAAAO,QAAA,MAA6CP,EAAAU,MAAA,2BAC7CiG,EAGA7F,WACA,aAEA5C,WACA,OAAWyB,EAAQpC,KAAA8C,OAAAnC,KAAAU,QCrDZ,MAAMoI,UAAiBvB,EAI9B5B,aAAA7D,GACA,MAAAiH,EAAAjH,EAAAO,QAAA,cACA,IAAA0G,EACA,OAEA,MAAA5G,EAAA,CAAoB4G,UAEpB,GADA5G,EAAAqE,SAAA1E,EAAAO,QAAA,YACAF,EAAAqE,SAMA,OAFArE,EAAA6G,MAAAlH,EAAAO,QAAA,eAAAP,EAAAU,MAAA,iCACAL,EAAA0G,YAAA/G,EAAAO,QAAA,MAA6CP,EAAAU,MAAA,2CAC7C,IAAesG,EAAQ,CAAE/F,OAAAjB,EAAAiB,OAAAZ,WALzBL,EAAAmH,UAAAF,EAAAlE,OAQAjC,WACA,iBAEAmG,aACA,OAAWtH,EAAQpC,KAAA8C,OAAA4G,OAAArI,OAEnB8F,eACA,OAAW/E,EAAQpC,KAAA8C,OAAA6G,MAAAtI,QCdnB,SAAAwI,EAAApH,EAAAqH,GACA,MAAApG,EAAAjB,EAAAiB,OAEAqG,EAAA,UACAC,EAAA,UACAC,EAAA,aACAC,EAAA,SAEA,SAAA/G,EAAAqD,GACA/D,EAAAU,MAAAqD,GAGA,SAAAqB,EAAAtE,GACA,OAAAd,EAAAoF,MAAAtE,GAGA,SAAAP,KAAA4E,GACA,OAAAnF,EAAAO,WAAA4E,GAGA,SAAAgC,EAAAjG,GACA,OAAAlB,EAAAmH,UAAAjG,GAsBA,SAAAwG,IACA,MAAAC,EApBA,WACA,MAAAC,EAAArH,EAAA,YACAmG,EAAAnG,EAAA,gBACA,GAAAmG,EAAA,CACA,MAAAmB,EAAAtH,EAAA,QACA,WAAAuH,EAAA,CAAuB7G,SAAAZ,OAAA,CAAkBuH,SAAAlB,OAAAmB,aAEzCD,GAAAlH,EAAA,gCAaAqH,IAVA,WACA,MAAAH,EAAArH,EAAA,gBACAmG,EAAAnG,EAAA,kBACA,GAAAmG,EACA,WAAAoB,EAAA,CAAuB7G,SAAAZ,OAAA,CAAkBuH,SAAAlB,UAEzCkB,GAAAlH,EAAA,8BAIAsH,GACA,GAAAL,EAAA,OAAAA,EACA,MAAAjB,EAAAnG,EAAA,0BACA,OAAAmG,EACA,IAAAoB,EAAA,CAAuB7G,SAAAZ,OAAA,CAAkBqG,eADzC,EAKA,SAAAuB,EAAAC,GACA,MAAAC,EAAA5H,EAAA,KACA4H,IACAD,EAAA7H,OAAA8H,YAEA/C,EAAA,MAAA1E,EAAA,iCAGA,MAAAoH,UAAqBrC,EACrB5B,aAAA5C,OAAiBA,EAAAZ,WACjBgF,MAAA,CAAapE,SAAAZ,WACbhC,OAAAC,eAAAf,KAAA,WAA8CqB,MAAA,KAC9CrB,KAAA6K,SAAA,GAGAC,cACA,SAEAF,eACA,QAAA5K,KAAA8C,OAAA8H,SAEAG,YACA,SAEAC,cACA,GAAAhL,KAAAiL,QAAAvG,OACA,OAAA1E,KAAAiL,QAQA,OAAa7I,EALb,CACApC,KAAA8C,OAAAuH,OACArK,KAAA8C,OAAAqG,KACAnJ,KAAA8C,OAAAwH,SACAY,OAAA5J,MAAAgD,IAAAhD,KAAAD,OAAAmD,KAAA,OAKA,MAAA2G,UAAAZ,EACAjE,aAAA8E,GACA,MAAAjC,EAAAnG,EAAA,6CACA,IAAAmG,EACA,OAEA,MAAAC,EAAA,IAAA+B,EAAA,CAAmCzH,SAAAZ,OAAA,CAAkBqG,UAErD,OADAC,EAAAtG,OAAAuG,KAAArG,EAAA,MAAAG,8BAA0EgG,EAAA5F,QAC1E4F,EAAA5F,MACA,eACAsE,EAAA,MAAA1E,EAAA,+CACA,MAAA8H,EAAAI,EAAAD,IAAAjI,EAAA,2BACAiG,EAAA6B,QAAA7H,KAAA6H,GACA,MAEA,eACA,mBACA,MAAAA,EAAAK,EAAAF,IAAAjI,aAAsFgG,EAAA5F,gBACtF6F,EAAA6B,QAAA7H,KAAA6H,GACA,MAEA,cACApD,EAAA,MAAA1E,EAAA,6CACA,MAAAoI,EAAAvI,KAAqCgD,IAAW7C,gCAAyC6C,EAAWxB,KAAA,SACpGgH,EAAA,IAAAjB,EAAA,CAAuC7G,SAAAZ,OAAA,CAAkBqG,KAAAoC,KACzDC,EAAA1I,OAAAC,UAAAC,EAAA,MAAAG,EAAA,uCACAqI,EAAAjI,KAAA6H,EACA,MAAAK,EAAAH,EAAAF,IAAAjI,EAAA,qCACAiG,EAAA6B,QAAA7H,KAAAoI,EAAAC,GACA,OAKA,OAFArC,EAAA4B,SAAA7H,gCAA4DgG,EAAA5F,QAC5D6F,EAAAtG,OAAAkG,MAAAhG,EAAA,MAAAG,mCAAgFgG,EAAA5F,QAChF6F,EAGA0B,cACA,OAAA9K,KAAA8C,OAAAqG,KAAA9H,OAuBA,MAAAqK,UAAAnB,EACAjE,aAAA/C,GACA,MAAAT,EAAA,GAEA,GADAA,EAAAuG,KAAArG,EAAA,MACAF,EAAAuG,KAAA,OACA,MAAAD,EAAA,IAAAsC,EAAA,CAAiChI,SAAAZ,WAEjC,IADAsG,EAAA7F,QAAA,OACA,CACA,MAAAoI,EAAAL,KAAAnI,EAAA,wDACA,QAAAwI,EAAAX,SAAA7H,EAAA,iDACAiG,EAAA6B,QAAA7H,KAAAuI,GACA,MAAAC,EAAA5I,EAAA,MACA,IAAA4I,EAGA,MAFAD,EAAA7I,OAAAC,UAAA6I,EASA,OALAxC,EAAA4B,QAAAtG,OAAA,GACAvB,EAAA,kEAEAL,EAAAkG,MAAAhG,EAAA,MAAAG,EAAA,2BACAuH,EAAAtB,GACAA,EAGA2B,YACA,UAIA,SAAAxH,EAAA6H,GACA,OAlDA,SAAAA,GACA,IAAAhC,EAAA+B,EAAA5B,MAAA6B,IAAAjB,IACA,IAAAf,EAAA,CACA,MAAAD,EAAAnG,EAAAiH,KAAkCjE,GAClC,IAAAmD,EACA,OAEAC,EAAA,IAAAmB,EAAA,CAAsB7G,SAAAZ,OAAA,CAAkBqG,UACxCtB,EAAA,MAAA1E,8BAAwDgG,EAAA9H,SAQxD,MANA,YAAA+H,EAAA0B,SAAAjD,EAAA,MACA1E,EAAA,mCAEAiG,EAAA7F,KAAA6H,GAAA,KACAV,EAAAtB,GACAA,EAAAwB,UAAA,QAAAxB,EAAA4B,SAAA7H,EAAA,sCACAiG,EAkCAyC,CAAAT,IAAAM,EAAAnC,MAAA6B,GAGA,SAAAE,EAAAF,GACA,MAAAP,EAAAiB,EAAAvC,QACAH,EAAA7F,EAAA6H,GAEA,OADAhC,MAAAyB,YACAzB,EAGA,MAAA2C,UAAyB7D,EACzB5B,eACA,MAAA0F,EAAAvJ,EAAAkB,SACAb,EAAA,GACAsG,EAAA,IAAA2C,EAAA,CAAgCrI,SAAAZ,WAIhC,OAHAsG,EAAAyB,SAAAiB,EAAAvC,QACAzG,EAAAmJ,SAAAjJ,EAAA,YACAoG,EAAA4B,QAAAM,EAAA,iBACAlC,EAAA4B,SAGAlI,EAAAmJ,WACAnJ,EAAAoJ,SAAAlJ,EAAA,QAEAF,EAAAnC,KAAAqC,EAAAiH,KAAmChE,GACnCnD,EAAAnC,MAGAyI,EAAA+C,QAAArJ,EAAAmJ,SAAsCrD,EAAOW,MAAA9G,GAAA,KAC7C2G,GAHAQ,EAAAoC,IAPApC,EAAAoC,GAaAC,eACA,QAAAjM,KAAA8C,OAAAmJ,SAEAC,eACA,QAAAlM,KAAA8C,OAAAoJ,SAEAvL,WACA,OAAayB,EAAQpC,KAAA8C,OAAAnC,KAAAU,QAIrB,SAAA+K,IACA,OAAW5J,EAAIC,EAAA,CAAaC,OAAAqJ,EAAAxC,MAAA3G,SAAA,mBAW5B,MAAAyJ,UAA4CnE,EAC5C5B,eACA,MAAAxD,EAAA,CAAsB+F,OAAA7F,EAAA,MACtBoG,EAAA,IAAAiD,EAAA,CAAmD3I,SAAAZ,WAenD,OAdAA,EAAA+F,SACA/F,EAAAwJ,cAAAtJ,EAAAiH,EAAAF,EAAAC,EAAAE,IAEApH,EAAAuG,KAAArG,EAAA,KACAF,EAAAuG,MACAD,EAAA5G,KAAA,oBAAA4G,EAAAmD,QAjBA,WACA,MAAAC,EAAgBhK,EAAIC,EAAA,CAAaC,OAASiG,EAAKjG,OAAAD,EAAAwH,GAAArH,SAAA,oBAI/C,OAHA4J,EAAA9H,QACAvB,EAAA,uCAEAqJ,EAcAC,GAEAL,IACAtJ,EAAAkG,MAAAhG,EAAA,MAAAG,EAAA,yDACOiG,EAAAsD,SAAA5J,EAAAwJ,eACPnJ,EAAA,uDAEAiG,EAGAmD,cACA,OAAAvM,KAAA8C,OAAA+F,OACA7I,KAAA8C,OAAAwJ,cACAtM,KAAA8C,OAAAwJ,cAAA/I,KADA,kBADA,MAMA,MAAAoJ,UAAwCzE,EACxC5B,eACA,MAAA3F,EAAAqC,EAAAiH,GACA,GAAAtJ,EACA,WAAAgM,EAAA,CACA7J,OAAA,CAAmBnC,QACnBiM,OAAAP,EAAA9C,UAKAjD,aAAA5C,OAAiBA,EAAAZ,SAAA8J,WACjB9E,MAAA,CAAapE,SAAAZ,WACbhC,OAAAC,eAAAf,KAAA,UAA6CqB,MAAAuL,IAG7CrJ,WACA,2BAEA5C,WACA,OAAAX,KAAA8C,OAAAnC,KAAAU,MAEAwL,UACA,MAAaN,QAAAhJ,EAAAT,SAAAN,QAA8BxC,KAAA4M,OAC3C,OAAArJ,EAIA,CAAcA,OAAAlC,MADd,oBAAAkC,EAAAf,EAAAM,EAAAwJ,cAAAjL,OAFA,KAKAyL,gBACA,MAAAP,QAAaA,EAAA/J,QAAgBxC,KAAA4M,OAC7B,OAAApK,GAAA,oBAAA+J,EAGA/J,EAFA,IAQA,MAAAsJ,UAAmC/D,EACnCzB,eACA,MAAAxD,EAAA,GAEA,GADAA,EAAAuG,KAAArG,EAAA,MACAF,EAAAuG,KAAA,SACA,MAAAD,EAAA,IAAA0C,EAAA,CAA0CpI,SAAAZ,WAY1C,OAXAsG,EAAAhG,QAAkBZ,EAAIC,EAAA,CACtBC,OAAAiK,EAAApD,MACA3G,SAAA,wBAEAE,EAAAkG,MAAAhG,EAAA,MAAAG,EAAA,yCACAiG,EAAA1E,QACAvB,EAAA,qCAEA0E,EAAA,MACA1E,EAAA,kEAEAiG,GAIA,MAAA2D,UAAyB7E,EACzB5B,eACA,MAAAxD,EAAA,GAEA,GADAA,EAAAqG,KAAAnG,EAAA,UACAF,EAAAqG,KACA,OAEA,IAAA6B,EAAAb,IACA,IAAAa,EAAA,CACA,MAAA7B,EAAAnG,EAAAiH,IAAA9G,EAAA,qBACA6H,EAAA,IAAAT,EAAA,CAA4B7G,SAAAZ,OAAA,CAAkBqG,UAE9CtB,EAAA,MACA1E,EAAA,qCAEA6H,EAAAzH,KAAA,aACAT,EAAAnC,KAAAqC,EAAAiH,IAAA9G,EAAA,qBACAL,EAAA+F,OAAA7F,EAAA,MAAAG,EAAA,iCACAL,EAAAzB,MAAqBgC,EAAWZ,IAAAU,EAAA,sBAChCL,EAAA0G,YAAAxG,EAAA,MAAqCG,EAAA,sBACrC,MAAAiG,EAAA,IAAA2D,EAAA,CAAgCrJ,SAAAZ,WAEhC,OADAsG,EAAA4B,UACA5B,EAGA7F,WACA,cAEA5C,WACA,OAAayB,EAAQpC,KAAA8C,OAAAnC,KAAAU,OAErBA,YACA,OAAaiC,EAAUtD,KAAA8C,OAAAzB,QAIvB,MAAA2L,UAAiC9E,EACjC5B,aAAA6C,GACA,MAAArG,EAAA,CAAsBqG,QACtBC,EAAA,IAAA4D,EAAA,CAAwCtJ,SAAAZ,WASxC,OARAA,EAAAnC,KAAAqC,EAAAiH,IAAA9G,EAAA,wBACAV,EAAAmB,QAAAwF,EACAtG,EAAA+F,OAAA7F,EAAA,MAAAG,EAAA,6BACAiG,EAAA4B,QAAAK,KAAAlI,EAAA,uBACAL,EAAAuG,KAAArG,EAAA,MAAAG,EAAA,4BACAiG,EAAA0D,UAAAV,IACAtJ,EAAAkG,MAAAhG,EAAA,MAAAG,EAAA,yBACAL,EAAA0G,YAAAxG,EAAA,MAAqCG,EAAA,yBACrCiG,EAGA7F,WACA,iBAEA5C,WACA,OAAayB,EAAQpC,KAAA8C,OAAAnC,KAAAU,QAcrB,MAAA4L,UAA0B/E,EAC1B5B,cAAA4G,QAAkBA,EAAAC,aAAA,EAAAC,YAAA,GAA+C,IACjE,MAAApB,EAAAvJ,EAAAkB,SACAb,EAAA,CAAsBoK,WACtB9D,EAAA,IAAA6D,EAAA,CAAiCvJ,SAAAZ,WAYjC,GAXAoK,GAAAC,IACArK,EAAAoK,QAAAlK,EAAA,YAEA,YAAAoG,EAAA8D,SAAArF,EAAA,aACA1E,EAAA,4CAEAL,EAAAsK,SAAApK,EAAA,YACAoK,IAAAtK,EAAAsK,UAAAvF,EAAA,cACA1E,EAAA,+CAEAL,EAAAqG,KAAAnG,EAAA,aACAF,EAAAqG,KAAA,CAKA,OADAC,EAAA4B,QAAAM,EAAA,mBAAAnI,EAAA,wBACAiG,EAAA4B,QAAAF,SACA,eACA,aAAA3H,8BAAyDiG,EAAA4B,QAAAF,iBAIzD,OAFAhI,EAAAnC,KAAAqC,EAAAiH,EAAA,aAAA9G,EAAA,wBACAL,EAAA0G,YAAAxG,EAAA,MAAqCG,EAAA,0BACrCiG,EAVAQ,EAAAoC,GAaAzI,WACA,kBAEA2J,cACA,OAAAlN,KAAA8C,OAAAoK,QAGAlN,KAAA8C,OAAAoK,QAAA7L,MAFA,GAIA+L,eACA,QAAApN,KAAA8C,OAAAsK,SAEAzM,WACA,OAAayB,EAAQpC,KAAA8C,OAAAnC,KAAAU,QAIrB,SAAAgK,EAAAD,GACA,MAAAO,EAAApI,EAAA6H,GAAA,eACA,GAAAO,EACA,OAAAA,EAEA,MAAA0B,EAAArK,EAAA,QACA,GAAAqK,EAAA,CACA,MAAAjE,EAAA,IAAAmB,EAAA,CAA4B7G,SAAAZ,OAAA,CAAkBqG,KAAAkE,KAE9C,OADAjE,EAAA7F,KAAA,cACA6F,GAIA,MAAAkE,UAA0BpF,EAC1B5B,cAAA4G,QAAkBA,EAAAK,WAAmB,IACrC,MAAAzK,EAAA,CAAsBoK,WACtB9D,EAAA,IAAAkE,EAAA,CAAiC5J,SAAAZ,WACjC,OAAAoK,GAAA,gBAAAA,EAAA7L,QACAyB,EAAA0G,YAAAxG,EAAA,KACAF,EAAA0G,cACAJ,EAAA0D,UAAA,GACA1D,IAGA8D,GAAAK,IACAzK,EAAAoK,QAAAlK,EAAA,8BAEAoG,EAAA4B,QAAAK,KAAAlI,EAAA,uBACAL,EAAAnC,KAAAqC,EAAAiH,GACAnH,EAAAuG,KAAArG,EAAA,MAAAG,EAAA,qBACAiG,EAAA0D,UAAAV,IACAtJ,EAAAkG,MAAAhG,EAAA,MAAAG,EAAA,0BACAL,EAAA0G,YAAAxG,EAAA,MAAqCG,EAAA,0BACrCiG,GAGA7F,WACA,kBAEA5C,WACA,MAAAA,KAAaA,GAAOX,KAAA8C,OACpB,OAAAnC,EAGayB,EAAQzB,EAAAU,OAFrB,GAIA6L,cACA,OAAAlN,KAAA8C,OAAAoK,QAGAlN,KAAA8C,OAAAoK,QAAA7L,MAFA,IAMA,SAAAmM,IACA,MAAAN,EAAAlK,EAAA,UACA,GAAAkK,EAIA,OAHAD,EAAA1D,MAAA,CAAoC2D,aACpCI,EAAA/D,MAAA,CAAuB2D,aACvB/J,EAAA,4BAIA,SAAAsK,IACA,MAAAP,EAAAlK,EAAA,eACA,GAAAkK,EAIA,OAHAD,EAAA1D,MAAA,CAAoC2D,aACpCI,EAAA/D,MAAA,CAAuB2D,aACvB/J,EAAA,4BAIA,MAAAuK,UAA6BxF,EAC7B5B,eACA,MAAA0F,EAAAvJ,EAAAkB,SACAb,EAAA,GACAsG,EAAA,IAAAsE,EAAA,CAAoChK,SAAAZ,WAKpC,GAJAA,EAAAsK,SAAApK,EAAA,YACAF,EAAAqG,KAAArG,EAAAsK,SACApK,EAAA,qBACAA,EAAA,iCACAF,EAAAqG,KAEA,YADAS,EAAAoC,GAIA,MAAAzI,KAAaA,GAAO6F,EACpBuE,EAAA,YAAApK,EACAqK,EAAAD,GAAA,aAAApK,EAEAT,EAAAuG,KAAArG,EAAA,MAAAG,mBAA2DI,iBAC3D,MAAAV,EAAAyI,KAAAnI,mBAA8EI,iBAa9E,OAZA6F,EAAA4B,QAAA,CAAAnI,GACA+K,IACA/K,EAAAC,OAAAC,UAAAC,EAAA,KACAH,EAAAC,OAAAC,UACAqG,EAAA4B,QAAA5H,KAAAkI,KAEAqC,GACAxK,qCAAmDI,kBAEnDT,EAAAkG,MAAAhG,EAAA,MAAAG,kBAA2DI,iBAC3DT,EAAA0G,YAAAxG,EAAA,MAAqCG,6BAAuCI,iBAE5E6F,EAGA7F,WACA,OAAAvD,KAAA8C,OAAAqG,KAAA9H,MAEA+L,eACA,QAAApN,KAAA8C,OAAAsK,UAaA,MAAAS,UAA0B3F,EAC1B5B,aAAAwH,GAAAvK,KAA4BA,EAAAwK,cAAAC,mBAC5B,MAAAlL,OAAaA,GAASgL,EAQtB,IAPAhL,EAAAnC,KAAAqC,EAAAiH,IAAA9G,EAAA,yBACAV,EAAAmB,QAAAkK,EACAC,GACAjN,OAAA+H,OAAA/F,EAfA,WACA,MAAAmL,EAAAjL,EAAA,KACA,OAAAiL,EAIA,CAAYA,QAAA5F,YADZrF,EAAAiH,IAAA9G,EAAA,2BAFA,GAYAkF,IAEAvF,EAAAuG,KAAArG,EAAA,MAA8BG,cAAwBI,KACtDuK,EAAAI,QAAA,KACA,CAEA,GADApL,EAAAkG,MAAAhG,EAAA,KACAF,EAAAkG,MAEA,OADAlG,EAAA0G,YAAAxG,EAAA,MAAyCG,6BAAuCI,KAChFuK,EAEA,MAAAK,EAAArC,EAAAvC,QACA,IAAA6E,EACA,UAAA1L,KAAA2L,KAAAL,EAEA,GADAI,EAAA1L,KAAA2L,GAEA,MAGAD,GACAjL,EAAA,kBAEAiL,EAAAvD,SAAAsD,EACAL,EAAAI,QAAA9K,KAAAgL,IAIAhJ,cACA,QAAApF,KAAA8C,OAAAsC,QAEAzE,WACA,OAAayB,EAAQpC,KAAA8C,OAAAnC,KAAAU,OAErBgH,kBACA,OAAArI,KAAA8C,OAAAuF,YAGajG,EAAQpC,KAAA8C,OAAAuF,YAAAhH,OAFrB,MAMA,MAAAiN,UAAAT,EACAvH,aAAA6C,GAAAoF,SAAwBA,EAAA,KAAAnJ,UAAA,MAAkC,IAC1D,MAAAtC,EAAA,CAAsByL,WAAAnJ,UAAA+D,QACtB,OAAA0E,EAAAtE,MAAA,IAAA+E,EAAA,CAA4C5K,SAAAZ,WAAiB,CAC7DS,KAAA,YACAwK,aAAA3I,EACA4I,eAAA,CACA,CAAAjB,EAAAxD,OACA,CAAAiE,GACA,CAAAC,GACA,CAAAC,EAAAnE,OACA,CAAA0D,EAAA1D,OACA,CAAA+D,EAAA/D,UAKAhG,WACA,OAAAvD,KAAA8C,OAAAyL,SACA,qBAEA,aAIA,MAAAC,UAAAX,EACAvH,aAAA6C,GAAA/D,QAAwBA,GAAU,IAClC,MAAAtC,EAAA,CAAsBsC,UAAA+D,QAEtB,GADArG,EAAA6G,MAAA3G,EAAA,SACAF,EAAA6G,MAGA,OAAAkE,EAAAtE,MAAA,IAAAiF,EAAA,CAAwC9K,SAAAZ,WAAiB,CACzDS,KAAA,kBACAyK,eAAA,CACA,CAAAjB,EAAAxD,OACA,CAAAkE,GACA,CAAAR,EAAA1D,MAAA,CAA6B4D,WAAA,IAC7B,CAAAG,EAAA/D,MAAA,CAA6BgE,SAAA,OAK7BhK,WACA,yBAIA,SAAAkL,EAAAC,GACA,MAAAvF,EAAAnG,EAAA,aACA,GAAAmG,EAIA,OAHAqF,EAAAjF,MAAAJ,EAAAuF,IACAJ,EAAA/E,MAAAJ,EAAAuF,IACAvL,EAAA,gCAIA,MAAAwL,UAAAd,EACAvH,cAAAlB,QAAkBA,GAAU,IAC5B,MAAAtC,EAAA,CAAsBsC,WAEtB,GADAtC,EAAAqG,KAAAnG,EAAA,aACAF,EAAAqG,KAGA,OAAA0E,EAAAtE,MAAA,IAAAoF,EAAA,CAA4CjL,SAAAZ,WAAiB,CAC7DS,KAAA,YACAyK,eAAA,CACA,CAAAf,EAAA1D,MAAA,CAA6B4D,WAAA,EAAAC,UAAA,IAC7B,CAAAE,EAAA/D,MAAA,CAA6BgE,SAAA,OAK7BhK,WACA,mBAaA,MAAAqL,UAAAf,EACAvH,cAAAlB,QAAkBA,GAAU,IAC5B,MAAAtC,EAAA,CAAsBsC,WAEtB,GADAtC,EAAAqG,KAAAnG,EAAA,cACAF,EAAAqG,KAGA,OAAA0E,EAAAtE,MAAA,IAAAqF,EAAA,CAA6ClL,SAAAZ,WAAiB,CAC9DS,KAAA,aACAwK,aAAA3I,EACA4I,eAAA,CACA,CAAAa,EAAAtF,UAKAhG,WACA,oBAIA,MAAAsL,UAAsB3G,EACtB5B,eACA,MAAAxD,EAAA,GACAsG,EAAA,IAAAyF,EAAA,CAA6BnL,SAAAZ,WAQ7B,OAPAsG,EAAAyB,SAAAiB,EAAAvC,QACAzG,EAAAgM,SAAA9L,EAAA,YACAoG,EAAA4B,QAAAM,EAAA,oBAAAnI,EAAA,iCACAL,EAAAnC,KAAAqC,EAAAiH,IAAA9G,EAAA,iCACAiG,EAAA+C,QAAoBvD,EAAOW,MAAA9G,GAC3BK,EAAAgM,UAAA1F,EAAA+C,SAAAhJ,EAAA,2CACAL,EAAA0G,YAAAxG,EAAA,MAAqCG,EAAA,kCACrCiG,EAGA7F,WACA,cAEA5C,WACA,OAAayB,EAAQpC,KAAA8C,OAAAnC,KAAAU,OAErByN,eACA,QAAA9O,KAAA8C,OAAAgM,UAIA,MAAAC,UAAwB7G,EACxB5B,eACA,MAAAxD,EAAA,GACAsG,EAAA,IAAA2F,EAAA,CAA+BrL,SAAAZ,WAE/B,GADAA,EAAAqG,KAAAnG,EAAA,WACAF,EAAAqG,KAOA,OAJAC,EAAA4B,QAAAM,EAAA,iBAAAnI,EAAA,sBACAL,EAAAnC,KAAAqC,EAAAiH,IAAA9G,EAAA,sBACAV,EAAAmB,QAAAwF,EACAtG,EAAA0G,YAAAxG,EAAA,MAAqCG,EAAA,wBACrCiG,EAGA7F,WACA,gBAEA5C,WACA,OAAayB,EAAQpC,KAAA8C,OAAAnC,KAAAU,QAIrB,SAAA2N,IACA,OAhYA,WACA,MAAAT,EAAAvL,EAAA,YACA,IAAAuL,EAAA,OACA,MAAAU,EAAAjM,EAAA,aACA,OAAAiM,EACAX,EAAA/E,MAAA0F,EAAA,CAAmCV,aAEnCvB,EAAAzD,MAAAgF,GAyXAA,IACAE,KAhFA,WACA,MAAArJ,EAAApC,EAAA,WACA,GAAAoC,EACA,OAAAwJ,EAAArF,MAAA,CAA6BnE,aAC7BqJ,EAAA,CAAkBrJ,aAClBuJ,EAAApF,MAAA,CAAuBnE,aACvBjC,EAAA,qCA2EAiC,IACAwJ,EAAArF,SACML,EAAIK,MAAA9G,IACVsM,EAAAxF,SACME,EAAQF,MAAA9G,IACdkM,EAAApF,QAsBA,MAAA2F,EAnBA,WACA,IAAAxL,EAAAgB,OAAA,SACA,MAAAyK,EAAA,GACA,QACA,MAAAhB,EAAArC,EAAAvC,QACAT,EAAAkG,IACA,IAAAlG,EAAA,CACAqF,EAAAzJ,QAAAvB,EAAA,6BACA,MAEA2F,EAAA+B,SAAAsD,EACAgB,EAAA/L,KAAA0F,GAEA,MAAAsG,EAAApM,EAAA,OAIA,OAHA8G,EAAAuF,UACAF,EAAA/L,KAAAgM,GAEAD,EAEAG,GAEA,OADA7M,EAAAkB,SAAAD,EAAAgB,QAAAvB,EAAA,uBACA+L,EAGO,SAAA3F,EAAA/C,EAAAsD,EAAA,IAEP,OAAAD,EADA,IAAwBxD,EAASG,GACjCsD,GCpzBA,SAAAyF,EAAAC,GACA,OAAAA,EAGA,MAAAC,EAAA,CACAC,KAAAzM,KAAAuB,KAAA,IACAD,OAAAgL,EACA5O,KAAA4O,EACAI,UAAAJ,EACAhM,KAAAgM,EACAzE,QAAAyE,EACAlH,YAAAkH,EACAP,WAAAO,EACAK,kBAAAL,EACAM,2BAAAN,GAGO,SAAAO,EAAAC,GAAqBN,UAAAO,EAAAP,GAA4B,IAGxD,SAAAE,EAAAM,GAAAC,UAA2BA,EAAAC,YAI3B,OAHAD,IACAA,EAAAD,EAAA3N,WAAA,KAAA2N,EAAA1N,MAAA,GAAA0N,GAEAD,EAAAL,UAAAM,EAAAC,EAAAC,GAGA,SAAA5K,EAAAjE,EAAA8O,EAAAb,KAAAlB,GACA,IAAA/M,EACA,SAEA,MAAAD,EAAA+O,EAAA9O,EAAAD,SAAAgN,GACA,OAAA2B,EAAAN,KAAA,CAAAM,EAAAzL,OAAAjD,EAAAiD,QAAAlD,IAGA,SAAAgP,EAAA/O,EAAA6O,GACA,OAAA5K,EAAAjE,EAAAqO,EAAA,CAAgCQ,YAGhC,SAAAG,EAAAhP,EAAAkO,GACA,OAAAjK,EAAAjE,EAAA0O,EAAArP,KAAA6O,GAGA,SAAAe,EAAAC,GACA,GAAAA,EAAAzF,OAAAyF,EAAA1F,QACA,OAAAkF,EAAAN,KAAA,CACAnK,EAAAiL,EAAA1N,OAAAqG,KAAA6G,EAAAlF,SACAvF,EAAAiL,EAAA1N,OAAAuG,SACAmH,EAAAvF,QAAA3G,IAAAf,GACAgC,EAAAiL,EAAA1N,OAAAkG,SAGA,MAAAyH,EAAAD,EAAA1N,OAAAuH,QAAAmG,EAAA1N,OAAAqG,KACAkB,EAAAmG,EAAA1N,OAAAuH,OAAA,CACAmG,EAAA1N,OAAAuH,OAAAhJ,MACA2O,EAAAzL,OAAAiM,EAAA1N,OAAAqG,KAAA5E,SACA,GACAmM,EAAAf,EAAAK,EAAAN,KAAA,IACArF,EACAmG,EAAA1N,OAAAqG,KAAA9H,MACAkE,EAAAiL,EAAA1N,OAAAwH,WACA,CAAS4F,UAAAM,EAAAxF,QAAAmF,QAAAK,IACT,OAAAR,EAAAN,KAAA,CAAAM,EAAAzL,OAAAkM,EAAAlM,QAAAmM,IAEA,SAAAnN,EAAAiN,GACA,OAAAR,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACA0F,EAAAC,GACAjL,EAAAiL,EAAA1N,OAAA8H,UACArF,EAAAiL,EAAA1N,OAAAC,aAGA,SAAA6N,EAAA9H,GACA,OAAAA,EAGAkH,EAAAN,KAAA,CACAnK,EAAAuD,EAAAhG,OAAA+F,WACAC,EAAAC,WAAAzE,IAAAhD,GAAAiE,EAAAjE,MAJA,GAOA,SAAAuP,EAAArB,GACA,OAAAQ,EAAAN,KAAA,CACAiB,EAAAnB,EAAA3E,UACAtF,EAAAiK,EAAA1M,OAAAmJ,UACA+D,EAAAzM,OAAAiM,EAAAxE,UACAzF,EAAAiK,EAAA1M,OAAAoJ,UACAoE,EAAAd,EAAA1M,OAAAnC,KAAA,CAAmCmQ,KAAAtB,IACnCoB,EAAApB,EAAArD,SACA5G,EAAAiK,EAAA1M,OAAAC,aASA,SAAAgO,EAAAP,GACA,MAAAjE,QAAWA,GAAUiE,EAAA5D,OACrB,OAAAoD,EAAAN,KAAA,CACAM,EAAAzL,OAAAiM,EAAA1N,OAAAnC,KAAA4D,QACAyL,EAAAJ,kBAAAI,EAAAN,KAAA,CACAM,EAAAH,2BAAAW,EAAA7P,MACA4E,EAAAiL,EAAA5D,OAAA9J,OAAA+F,QACAwH,EAAAG,EAAA5D,OAAA9J,OAAAwJ,cAAAkE,GACAjL,EAAAiL,EAAA5D,OAAA9J,OAAAuG,SACAmH,EAAA5D,OAAApK,KACAgO,EAAA5D,OAAApK,KAAA8B,IACA,oBAAAiI,EAAAyE,IAjBA,SAAAA,EAAAb,GACA,OAAAH,EAAAN,KAAA,CACAW,EAAAW,EAAAlO,OAAAzB,MAAA8O,GACA5K,EAAAyL,EAAAlO,OAAAC,cAcAV,CAAA2O,EAAAR,GAAAK,GAFA,GAIAtL,EAAAiL,EAAA5D,OAAA9J,OAAAkG,UAEAzD,EAAAiL,EAAA1N,OAAAC,aAGA,SAAA4N,EAAAM,GACA,OAAAA,EAAAvM,OACAsL,EAAAN,KAAA,CACAnK,EAAA0L,EAAAnO,OAAAuG,SACA4H,EAAA3M,IAAAyM,GACAxL,EAAA0L,EAAAnO,OAAAkG,SAJA,GA+CA,SAAAkI,EAAAV,GACA,OAAAR,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAyL,UACAhJ,EAAAiL,EAAA1N,OAAAsC,SACAG,EAAAiL,EAAA1N,OAAAqG,MACA5D,EAAAiL,EAAA1N,OAAA6G,OACA2G,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,KAlBlCW,EAmBAX,EAlBAW,EAAArO,OAAAuF,YAGA2H,EAAAN,KAAA,CACAnK,EAAA4L,EAAArO,OAAAmL,OACA+B,EAAAzL,OAAA4M,EAAArO,OAAAuF,YAAA9D,QACAyL,EAAA3H,YAAAsH,EAAAwB,EAAArO,OAAAuF,YAAAhH,MAAA,CAA8D8O,QAAAgB,OAL9D,IAkBA5L,EAAAiL,EAAA1N,OAAAuG,MACA+H,EAAAZ,EAAAtC,QAAAsC,GACAjL,EAAAiL,EAAA1N,OAAAkG,OACAzD,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,IAxBT,IAAAW,EAoGA,SAAAE,EAAAb,EAAAc,GACA,OAAAtB,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAsK,UACA7H,EAAAiL,EAAA1N,OAAAqG,KAAA6G,EAAAlF,SACAvF,EAAAiL,EAAA1N,OAAAuG,MACA2G,EAAAN,KAAAc,EAAAxF,QAAA1G,IAAAf,IACAgC,EAAAiL,EAAA1N,OAAAkG,OACAzD,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,EAAAc,WApPTtB,EAAAlP,OAAA+H,OAAA,GAAuB4G,EAAAO,GA0PvB,MAAAuB,EAAA,CACAC,UAAAN,EACAO,kBAAAP,EACAQ,UAAAR,EACAS,UAnJA,SAAAnB,EAAAc,GACA,MAAAM,EAAApB,EAAAxF,QAAA,CACAgF,EAAAzM,OAAAiN,EAAAxF,UACAsF,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,EAAAc,WAClC/L,EAAAiL,EAAA1N,OAAAuG,MACA2G,EAAAN,KAAAc,EAAA1D,UAAAxI,IAAAuM,IACAtL,EAAAiL,EAAA1N,OAAAkG,QACA,GACA,OAAAgH,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAoK,YACA0E,EACArM,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,EAAAc,YAuITO,UApIA,SAAArB,EAAAc,GACA,OAAAtB,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAoK,SACA3H,EAAAiL,EAAA1N,OAAAsK,UACA7H,EAAAiL,EAAA1N,OAAAqG,MACA6G,EAAAzM,OAAAiN,EAAAxF,UACAsF,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,EAAAc,WAClC/L,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,EAAAc,YA4HTQ,WAAAZ,EACAa,MA/FA,SAAAvB,EAAAc,GACA,OAAAtB,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAgM,UACAkB,EAAAzM,OAAAiN,EAAAxF,UACAsF,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,EAAAc,WAClCV,EAAAJ,EAAArE,SACA5G,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,EAAAc,YAwFTU,MAtFA,SAAAxB,EAAAc,GACA,OAAAtB,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAqG,MACA6G,EAAAzM,OAAAiN,EAAAxF,UACAsF,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,EAAAc,WAClC/L,EAAAiL,EAAA1N,OAAA+F,QACAtD,EAAAiL,EAAA1N,OAAAzB,OACAkE,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,EAAAc,YA8ETW,QA5EA,SAAAzB,GACA,OAAAR,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAqG,MACA6G,EAAAzM,OAAAiN,EAAAxF,UACAsF,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,IAClCjL,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,KAsETrJ,SApEA,SAAAqJ,GACA,OAAAR,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAwF,EAAAG,EAAA1N,OAAA4G,OAAA8G,GACAjL,EAAAiL,EAAA1N,OAAAqE,UACAkJ,EAAAG,EAAA1N,OAAA6G,MAAA6G,GACAjL,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,KA8DTjC,SA5DA,SAAAiC,GACA,OAAAR,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAqG,MACAmH,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,IAClCjL,EAAAiL,EAAA1N,OAAA+F,QACAmH,EAAAzM,OAAAiN,EAAAxF,UACAzF,EAAAiL,EAAA1N,OAAAuG,SACAmH,EAAA1D,UAAAxI,IAAAuM,GACAtL,EAAAiL,EAAA1N,OAAAkG,OACAzD,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,KAkDT0B,KAhDA,SAAA1B,GACA,OAAAR,EAAAhB,WAAAgB,EAAAN,KAAA,CACAiB,EAAAH,EAAA3F,UACAtF,EAAAiL,EAAA1N,OAAAqG,MACAmH,EAAAE,EAAA1N,OAAAnC,KAAA,CAAkCmQ,KAAAN,IAClCjL,EAAAiL,EAAA1N,OAAAuG,MACA+H,EAAAZ,EAAAlH,OAAAkH,GACAjL,EAAAiL,EAAA1N,OAAAkG,OACAzD,EAAAiL,EAAA1N,OAAA0G,eACA,CAASsH,KAAAN,KAwCT2B,aAtCA,SAAAC,EAAAd,GACA,OAAAtB,EAAAN,KAAA,CACAM,EAAAzL,OAAA6N,EAAAtP,OAAAzB,MAAAkD,QACAyL,EAAAhB,WACAgB,EAAAN,KAAA,KAAAM,EAAArP,KAAAyR,EAAA/Q,MAAA,CAAwCyP,KAAAsB,EAAAd,WAAkB,MAC1D,CAASR,KAAAsB,EAAAd,WAET/L,EAAA6M,EAAAtP,OAAAC,cAgCAsP,SAAAhB,EACAiB,eAAAjB,EACAkB,QAAAlB,EACAmB,QAAAnB,EACAoB,qBAAAvB,EACA9B,IAvBA,SAAAoB,GACA,OAAAR,EAAAzL,OAAAiM,EAAAjM,UA+BA,SAAA6M,EAAAsB,EAAApB,GACA,IAAAoB,EAAA,OACA,MAAAC,EAAAD,EAAApO,IAAAsO,IATA,SAAApC,EAAAc,GAEA,IADAC,EAAAf,EAAAjN,MAEA,UAAA8D,eAA+BmJ,EAAAjN,wBAE/B,OAAAgO,EAAAf,EAAAjN,MAAAiN,EAAAc,IAIAuB,CAAAD,EAAAtB,IACA,OAAAtB,EAAAN,KAAAiD,GAEA,OAAAvB,EAAArB,GCjRA,SAAA+C,GAAAC,OAAgCA,EAAAC,eAChC,UAAAC,KAAAD,EAAA,CACA,MAAArS,KAAWA,GAAOsS,EAClBpP,eAAiClD,eAAkBoS,EAAA9R,IAAAN,GAAA4C,+BACzC+B,EAAK2N,EAAAvP,OAAAuP,EAAAnQ,OAAAnC,KAAAsS,EAAApP,IAIf,SAAAqP,EAAA/D,GACA,MAAAgE,EAAA,IAAAhE,EAAA4D,OAAAzJ,UAAA4B,OAAApC,GAAA,cAAAA,EAAAvF,MACA6P,EAkCA,WACA,MAAA9O,EAAA,IAAA+O,IACAlM,EAAAgI,EAAAmE,IAAApI,OAAApC,GAAA,aAAAA,EAAAvF,MACA,UAAAgQ,KAAApM,EAAA,CACA,MAAAqM,EAAAlP,EAAArD,IAAAsS,EAAA7J,QACAC,EAAAwF,EAAA4D,OAAA9R,IAAAsS,EAAApM,UACAwC,IAGA6J,EACAA,EAAApQ,KAAAuG,GAEArF,EAAAmP,IAAAF,EAAA7J,OAAA,CAAAC,KAGA,OAAArF,EAjDAoP,GAEA,UAAAtT,KAAA+S,QACAQ,EAAAvT,GAGA,SAAAuT,EAAAvT,GACA,MAAAwT,EAAA,IAAAC,IAAAC,EAAA1T,GAAAkE,IAAAyP,KAAApT,OACAqT,EAAA7E,EAAA6E,SAAA/S,IAAAb,EAAAO,OAAA,GACAsT,EAAAb,EAAAnS,IAAAb,EAAAO,OAAA,GACA,UAAAuT,IAAA,IAAAF,KAAAC,GAAA,CACA,MAAAE,EAAAL,EAAAI,SACAE,EAAAD,EAAAP,EAAAM,EAAA9T,GACA,UAAAiU,KAAAF,EACAP,EAAAU,IAAAD,EAAA1T,OAKA,SAAAyT,EAAAD,EAAAI,EAAAL,EAAA/K,GACA,UAAAkL,KAAAF,EAAA,CACA,MAAAxT,KAAaA,GAAO0T,EACpB,GAAA1T,GAAA4T,EAAAC,IAAA7T,GAAA,CACA,MAAAkD,oBAA0ClD,uDAA0DwI,EAAAxI,6CACtF2E,EAAK4O,EAAAxQ,OAAA2Q,EAAAvR,OAAAnC,KAAAuT,EAAArQ,KAKnB,SAAAiQ,EAAA1T,GACA,OAAAA,EAAA8N,QACAhD,OAAA,EAAgB3H,UAAK,cAAAA,IAsBd,SAAAkR,EAAA1E,GACP,MAAAZ,EA1FA,SAAAmE,GACA,MAAAP,EAAA,IAAAM,IACAL,EAAA,IAAAa,IACAG,EAAA,IAAAX,IACA,UAAAvK,KAAAwK,EACA,GAAAxK,EAAA1D,QAAA,CACA,MAAAoO,EAAAQ,EAAA/S,IAAA6H,EAAAnI,MACA6S,EACAA,EAAApQ,KAAA0F,GAEAkL,EAAAP,IAAA3K,EAAAnI,KAAA,CAAAmI,SAIAA,EAAAnI,OAGAoS,EAAAyB,IAAA1L,EAAAnI,MAGAqS,EAAAsB,IAAAxL,GAFAiK,EAAAU,IAAA3K,EAAAnI,KAAAmI,IAKA,OAAUwK,MAAAP,SAAAiB,WAAAhB,cAmEV0B,CAAA3E,GACA,UACA+C,EAAA3D,MACA+D,EAAA/D,ICjGAjP,EAAAQ,EAAAiU,EAAA,0BAAApL,IAAArJ,EAAAQ,EAAAiU,EAAA,0BAAA7E,IAAA5P,EAAAQ,EAAAiU,EAAA,6BAAAF","file":"webidl2.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebIDL2\"] = factory();\n\telse\n\t\troot[\"WebIDL2\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * @param {string} identifier\r\n */\r\nexport function unescape(identifier) {\r\n  return identifier.startsWith('_') ? identifier.slice(1) : identifier;\r\n}\r\n\r\n/**\r\n * Parses comma-separated list\r\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\r\n * @param {object} args\r\n * @param {Function} args.parser parser function for each item\r\n * @param {boolean} [args.allowDangler] whether to allow dangling comma\r\n * @param {string} [args.listName] the name to be shown on error messages\r\n */\r\nexport function list(tokeniser, { parser, allowDangler, listName = \"list\" }) {\r\n  const first = parser(tokeniser);\r\n  if (!first) {\r\n    return [];\r\n  }\r\n  first.tokens.separator = tokeniser.consume(\",\");\r\n  const items = [first];\r\n  while (first.tokens.separator) {\r\n    const item = parser(tokeniser);\r\n    if (!item) {\r\n      if (!allowDangler) {\r\n        tokeniser.error(`Trailing comma in ${listName}`);\r\n      }\r\n      break;\r\n    }\r\n    item.tokens.separator = tokeniser.consume(\",\");\r\n    items.push(item);\r\n    if (!item.tokens.separator) break;\r\n  }\r\n  return items;\r\n}\r\n\r\n/**\r\n * @param {import(\"../tokeniser\").Tokeniser} tokeniser\r\n */\r\nexport function const_value(tokeniser) {\r\n  return tokeniser.consume(\"true\", \"false\", \"Infinity\", \"-Infinity\", \"NaN\", \"decimal\", \"integer\");\r\n}\r\n\r\n/**\r\n * @param {object} token\r\n * @param {string} token.type\r\n * @param {string} token.value\r\n */\r\nexport function const_data({ type, value }) {\r\n  switch (type) {\r\n    case \"true\":\r\n    case \"false\":\r\n      return { type: \"boolean\", value: type === \"true\" };\r\n    case \"Infinity\":\r\n    case \"-Infinity\":\r\n      return { type: \"Infinity\", negative: type.startsWith(\"-\") };\r\n    case \"[\":\r\n      return { type: \"sequence\", value: [] };\r\n    case \"decimal\":\r\n    case \"integer\":\r\n        return { type: \"number\", value };\r\n    case \"string\":\r\n      return { type: \"string\", value: value.slice(1, -1) };\r\n    default:\r\n      return { type };\r\n  }\r\n}\r\n","/**\r\n * @param {string} text\r\n */\r\nfunction lastLine(text) {\r\n  const splitted = text.split(\"\\n\");\r\n  return splitted[splitted.length - 1];\r\n}\r\n\r\n/**\r\n * @param {string} message error message\r\n * @param {\"Syntax\" | \"Validation\"} type error type\r\n */\r\nfunction error(source, position, current, message, type) {\r\n  /**\r\n   * @param {number} count\r\n   */\r\n  function sliceTokens(count) {\r\n    return count > 0 ?\r\n      source.slice(position, position + count) :\r\n      source.slice(Math.max(position + count, 0), position);\r\n  }\r\n\r\n  function tokensToText(inputs, { precedes } = {}) {\r\n    const text = inputs.map(t => t.trivia + t.value).join(\"\");\r\n    const nextToken = source[position];\r\n    if (nextToken.type === \"eof\") {\r\n      return text;\r\n    }\r\n    if (precedes) {\r\n      return text + nextToken.trivia;\r\n    }\r\n    return text.slice(nextToken.trivia.length);\r\n  }\r\n\r\n  const maxTokens = 5; // arbitrary but works well enough\r\n  const line =\r\n    source[position].type !== \"eof\" ? source[position].line :\r\n    source.length > 1 ? source[position - 1].line :\r\n    1;\r\n\r\n  const precedingLine = lastLine(\r\n    tokensToText(sliceTokens(-maxTokens), { precedes: true })\r\n  );\r\n\r\n  const subsequentTokens = sliceTokens(maxTokens);\r\n  const subsequentText = tokensToText(subsequentTokens);\r\n  const sobsequentLine = subsequentText.split(\"\\n\")[0];\r\n\r\n  const spaced = \" \".repeat(precedingLine.length) + \"^ \" + message;\r\n  const contextualMessage = precedingLine + sobsequentLine + \"\\n\" + spaced;\r\n\r\n  const contextType = type === \"Syntax\" ? \"since\" : \"inside\";\r\n  const grammaticalContext = current ? `, ${contextType} \\`${current.partial ? \"partial \" : \"\"}${current.type} ${current.name}\\`` : \"\";\r\n  return {\r\n    message: `${type} error at line ${line}${grammaticalContext}:\\n${contextualMessage}`,\r\n    line,\r\n    input: subsequentText,\r\n    tokens: subsequentTokens\r\n  };\r\n}\r\n\r\n/**\r\n * @param {string} message error message\r\n */\r\nexport function syntaxError(source, position, current, message) {\r\n  return error(source, position, current, message, \"Syntax\");\r\n}\r\n\r\n/**\r\n * @param {string} message error message\r\n */\r\nexport function validationError(source, token, current, message) {\r\n  return error(source, token.index, current, message, \"Validation\").message;\r\n}\r\n","import { syntaxError } from \"./error.js\";\r\n\r\n// These regular expressions use the sticky flag so they will only match at\r\n// the current location (ie. the offset of lastIndex).\r\nconst tokenRe = {\r\n  // This expression uses a lookahead assertion to catch false matches\r\n  // against integers early.\r\n  \"decimal\": /-?(?=[0-9]*\\.|[0-9]+[eE])(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][-+]?[0-9]+)?|[0-9]+[Ee][-+]?[0-9]+)/y,\r\n  \"integer\": /-?(0([Xx][0-9A-Fa-f]+|[0-7]*)|[1-9][0-9]*)/y,\r\n  \"identifier\": /[_-]?[A-Za-z][0-9A-Z_a-z-]*/y,\r\n  \"string\": /\"[^\"]*\"/y,\r\n  \"whitespace\": /[\\t\\n\\r ]+/y,\r\n  \"comment\": /((\\/(\\/.*|\\*([^*]|\\*[^/])*\\*\\/)[\\t\\n\\r ]*)+)/y,\r\n  \"other\": /[^\\t\\n\\r 0-9A-Za-z]/y\r\n};\r\n\r\nexport const stringTypes = [\r\n  \"ByteString\",\r\n  \"DOMString\",\r\n  \"USVString\"\r\n];\r\n\r\nexport const argumentNameKeywords = [\r\n  \"attribute\",\r\n  \"callback\",\r\n  \"const\",\r\n  \"deleter\",\r\n  \"dictionary\",\r\n  \"enum\",\r\n  \"getter\",\r\n  \"includes\",\r\n  \"inherit\",\r\n  \"interface\",\r\n  \"iterable\",\r\n  \"maplike\",\r\n  \"namespace\",\r\n  \"partial\",\r\n  \"required\",\r\n  \"setlike\",\r\n  \"setter\",\r\n  \"static\",\r\n  \"stringifier\",\r\n  \"typedef\",\r\n  \"unrestricted\"\r\n];\r\n\r\nconst nonRegexTerminals = [\r\n  \"-Infinity\",\r\n  \"FrozenArray\",\r\n  \"Infinity\",\r\n  \"NaN\",\r\n  \"Promise\",\r\n  \"boolean\",\r\n  \"byte\",\r\n  \"double\",\r\n  \"false\",\r\n  \"float\",\r\n  \"implements\",\r\n  \"legacyiterable\",\r\n  \"long\",\r\n  \"mixin\",\r\n  \"null\",\r\n  \"octet\",\r\n  \"optional\",\r\n  \"or\",\r\n  \"readonly\",\r\n  \"record\",\r\n  \"sequence\",\r\n  \"short\",\r\n  \"true\",\r\n  \"unsigned\",\r\n  \"void\"\r\n].concat(argumentNameKeywords, stringTypes);\r\n\r\nconst punctuations = [\r\n  \"(\",\r\n  \")\",\r\n  \",\",\r\n  \"...\",\r\n  \":\",\r\n  \";\",\r\n  \"<\",\r\n  \"=\",\r\n  \">\",\r\n  \"?\",\r\n  \"[\",\r\n  \"]\",\r\n  \"{\",\r\n  \"}\"\r\n];\r\n\r\n/**\r\n * @param {string} str\r\n */\r\nfunction tokenise(str) {\r\n  const tokens = [];\r\n  let lastCharIndex = 0;\r\n  let trivia = \"\";\r\n  let line = 1;\r\n  let index = 0;\r\n  while (lastCharIndex < str.length) {\r\n    const nextChar = str.charAt(lastCharIndex);\r\n    let result = -1;\r\n\r\n    if (/[\\t\\n\\r ]/.test(nextChar)) {\r\n      result = attemptTokenMatch(\"whitespace\", { noFlushTrivia: true });\r\n    } else if (nextChar === '/') {\r\n      result = attemptTokenMatch(\"comment\", { noFlushTrivia: true });\r\n    }\r\n\r\n    if (result !== -1) {\r\n      const currentTrivia = tokens.pop().value;\r\n      line += (currentTrivia.match(/\\n/g) || []).length;\r\n      trivia += currentTrivia;\r\n      index -= 1;\r\n    } else if (/[-0-9.A-Z_a-z]/.test(nextChar)) {\r\n      result = attemptTokenMatch(\"decimal\");\r\n      if (result === -1) {\r\n        result = attemptTokenMatch(\"integer\");\r\n      }\r\n      if (result === -1) {\r\n        result = attemptTokenMatch(\"identifier\");\r\n        const token = tokens[tokens.length - 1];\r\n        if (result !== -1 && nonRegexTerminals.includes(token.value)) {\r\n          token.type = token.value;\r\n        }\r\n      }\r\n    } else if (nextChar === '\"') {\r\n      result = attemptTokenMatch(\"string\");\r\n    }\r\n\r\n    for (const punctuation of punctuations) {\r\n      if (str.startsWith(punctuation, lastCharIndex)) {\r\n        tokens.push({ type: punctuation, value: punctuation, trivia, line, index });\r\n        trivia = \"\";\r\n        lastCharIndex += punctuation.length;\r\n        result = lastCharIndex;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // other as the last try\r\n    if (result === -1) {\r\n      result = attemptTokenMatch(\"other\");\r\n    }\r\n    if (result === -1) {\r\n      throw new Error(\"Token stream not progressing\");\r\n    }\r\n    lastCharIndex = result;\r\n    index += 1;\r\n  }\r\n\r\n  // remaining trivia as eof\r\n  tokens.push({\r\n    type: \"eof\",\r\n    value: \"\",\r\n    trivia\r\n  });\r\n\r\n  return tokens;\r\n\r\n  /**\r\n   * @param {keyof tokenRe} type\r\n   * @param {object} [options]\r\n   * @param {boolean} [options.noFlushTrivia]\r\n   */\r\n  function attemptTokenMatch(type, { noFlushTrivia } = {}) {\r\n    const re = tokenRe[type];\r\n    re.lastIndex = lastCharIndex;\r\n    const result = re.exec(str);\r\n    if (result) {\r\n      tokens.push({ type, value: result[0], trivia, line, index });\r\n      if (!noFlushTrivia) {\r\n        trivia = \"\";\r\n      }\r\n      return re.lastIndex;\r\n    }\r\n    return -1;\r\n  }\r\n}\r\n\r\nexport class Tokeniser {\r\n  /**\r\n   * @param {string} idl\r\n   */\r\n  constructor(idl) {\r\n    this.source = tokenise(idl);\r\n    this.position = 0;\r\n  }\r\n\r\n  /**\r\n   * @param {string} message\r\n   */\r\n  error(message) {\r\n    throw new WebIDLParseError(syntaxError(this.source, this.position, this.current, message));\r\n  }\r\n\r\n  /**\r\n   * @param {string} type\r\n   */\r\n  probe(type) {\r\n    return this.source.length > this.position && this.source[this.position].type === type;\r\n  }\r\n\r\n  /**\r\n   * @param  {...string} candidates\r\n   */\r\n  consume(...candidates) {\r\n    for (const type of candidates) {\r\n      if (!this.probe(type)) continue;\r\n      const token = this.source[this.position];\r\n      this.position++;\r\n      return token;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} position\r\n   */\r\n  unconsume(position) {\r\n    this.position = position;\r\n  }\r\n}\r\n\r\nclass WebIDLParseError extends Error {\r\n  constructor({ message, line, input, tokens }) {\r\n    super(message);\r\n    this.name = \"WebIDLParseError\"; // not to be mangled\r\n    this.line = line;\r\n    this.input = input;\r\n    this.tokens = tokens;\r\n  }\r\n}\r\n","export class ArrayBase extends Array {\r\n  constructor({ source, tokens }) {\r\n    super();\r\n    Object.defineProperties(this, {\r\n      source: { value: source },\r\n      tokens: { value: tokens }\r\n    });\r\n  }\r\n}\r\n","export class Base {\r\n  constructor({ source, tokens }) {\r\n    Object.defineProperties(this, {\r\n      source: { value: source },\r\n      tokens: { value: tokens }\r\n    });\r\n  }\r\n\r\n  toJSON() {\r\n    const json = { type: undefined, name: undefined, inheritance: undefined };\r\n    let proto = this;\r\n    while (proto !== Object.prototype) {\r\n      const descMap = Object.getOwnPropertyDescriptors(proto);\r\n      for (const [key, value] of Object.entries(descMap)) {\r\n        if (value.enumerable || value.get) {\r\n          json[key] = this[key];\r\n        }\r\n      }\r\n      proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return json;\r\n  }\r\n}\r\n","import { Base } from \"./base.js\";\r\n\r\nexport class Token extends Base {\r\n  /**\r\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\r\n   * @param {string} type\r\n   */\r\n  static parser(tokeniser, type) {\r\n    return () => {\r\n      const value = tokeniser.consume(type);\r\n      if (value) {\r\n        return new Token({ source: tokeniser.source, tokens: { value } });\r\n      }\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.tokens.value.value;\r\n  }\r\n}\r\n","import { Base } from \"./base.js\";\r\nimport { const_data, const_value } from \"./helpers.js\";\r\n\r\nexport class Default extends Base {\r\n  /**\r\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\r\n   */\r\n  static parse(tokeniser) {\r\n    const assign = tokeniser.consume(\"=\");\r\n    if (!assign) {\r\n      return null;\r\n    }\r\n    const def = const_value(tokeniser) || tokeniser.consume(\"string\", \"null\", \"[\") || tokeniser.error(\"No value for default\");\r\n    const expression = [def];\r\n    if (def.type === \"[\") {\r\n      const close = tokeniser.consume(\"]\") || tokeniser.error(\"Default sequence value must be empty\");\r\n      expression.push(close);\r\n    }\r\n    return new Default({ source: tokeniser.source, tokens: { assign }, expression });\r\n  }\r\n\r\n  constructor({ source, tokens, expression }) {\r\n    super({ source, tokens });\r\n    Object.defineProperty(this, \"expression\", { value: expression });\r\n  }\r\n\r\n  get type() {\r\n    return const_data(this.expression[0]).type;\r\n  }\r\n  get value() {\r\n    return const_data(this.expression[0]).value;\r\n  }\r\n  get negative() {\r\n    return const_data(this.expression[0]).negative;\r\n  }\r\n}\r\n","import { list, unescape } from \"./helpers.js\";\r\nimport { Token } from \"./token.js\";\r\nimport { Base } from \"./base.js\";\r\n\r\nclass EnumValue extends Token {\r\n  /**\r\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\r\n   */\r\n  static parse(tokeniser) {\r\n    const value = tokeniser.consume(\"string\");\r\n    if (value) {\r\n      return new EnumValue({ source: tokeniser.source, tokens: { value } });\r\n    }\r\n  }\r\n\r\n  get type() {\r\n    return \"enum-value\";\r\n  }\r\n  get value() {\r\n    return super.value.slice(1, -1);\r\n  }\r\n}\r\n\r\nexport class Enum extends Base {\r\n  /**\r\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\r\n   */\r\n  static parse(tokeniser) {\r\n    const tokens = {};\r\n    tokens.base = tokeniser.consume(\"enum\");\r\n    if (!tokens.base) {\r\n      return;\r\n    }\r\n    tokens.name = tokeniser.consume(\"identifier\") || tokeniser.error(\"No name for enum\");\r\n    const ret = tokeniser.current = new Enum({ source: tokeniser.source, tokens });\r\n    tokens.open = tokeniser.consume(\"{\") || tokeniser.error(\"Bodyless enum\");\r\n    ret.values = list(tokeniser, {\r\n      parser: EnumValue.parse,\r\n      allowDangler: true,\r\n      listName: \"enumeration\"\r\n    });\r\n    if (tokeniser.probe(\"string\")) {\r\n      tokeniser.error(\"No comma between enum values\");\r\n    }\r\n    tokens.close = tokeniser.consume(\"}\") || tokeniser.error(\"Unexpected value in enum\");\r\n    if (!ret.values.length) {\r\n      tokeniser.error(\"No value in enum\");\r\n    }\r\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"No semicolon after enum\");\r\n    return ret;\r\n  }\r\n\r\n  get type() {\r\n    return \"enum\";\r\n  }\r\n  get name() {\r\n    return unescape(this.tokens.name.value);\r\n  }\r\n}\r\n","import { Base } from \"./base.js\";\r\nimport { unescape } from \"./helpers.js\";\r\n\r\nexport class Includes extends Base {\r\n  /**\r\n   * @param {import(\"../tokeniser\").Tokeniser} tokeniser\r\n   */\r\n  static parse(tokeniser) {\r\n    const target = tokeniser.consume(\"identifier\");\r\n    if (!target) {\r\n      return;\r\n    }\r\n    const tokens = { target };\r\n    tokens.includes = tokeniser.consume(\"includes\");\r\n    if (!tokens.includes) {\r\n      tokeniser.unconsume(target.index);\r\n      return;\r\n    }\r\n    tokens.mixin = tokeniser.consume(\"identifier\") || tokeniser.error(\"Incomplete includes statement\");\r\n    tokens.termination = tokeniser.consume(\";\") || tokeniser.error(\"No terminating ; for includes statement\");\r\n    return new Includes({ source: tokeniser.source, tokens });\r\n  }\r\n\r\n  get type() {\r\n    return \"includes\";\r\n  }\r\n  get target() {\r\n    return unescape(this.tokens.target.value);\r\n  }\r\n  get includes() {\r\n    return unescape(this.tokens.mixin.value);\r\n  }\r\n}\r\n","\"use strict\";\r\n\r\nimport { const_data, const_value, list, unescape } from \"./productions/helpers.js\";\r\nimport { argumentNameKeywords, stringTypes, Tokeniser } from \"./tokeniser.js\";\r\nimport { ArrayBase } from \"./productions/array-base.js\";\r\nimport { Base } from \"./productions/base.js\";\r\nimport { Token } from \"./productions/token.js\";\r\nimport { Default } from \"./productions/default.js\";\r\nimport { Enum } from \"./productions/enum.js\";\r\nimport { Includes } from \"./productions/includes.js\";\r\n\r\n/**\r\n * @param {Tokeniser} tokeniser\r\n * @param {object} options\r\n * @param {boolean} [options.concrete]\r\n */\r\nfunction parseByTokens(tokeniser, options) {\r\n  const source = tokeniser.source;\r\n\r\n  const DECIMAL = \"decimal\";\r\n  const INT = \"integer\";\r\n  const ID = \"identifier\";\r\n  const STR = \"string\";\r\n\r\n  function error(str) {\r\n    tokeniser.error(str);\r\n  }\r\n\r\n  function probe(type) {\r\n    return tokeniser.probe(type);\r\n  }\r\n\r\n  function consume(...candidates) {\r\n    return tokeniser.consume(...candidates);\r\n  }\r\n\r\n  function unconsume(position) {\r\n    return tokeniser.unconsume(position);\r\n  }\r\n\r\n  function integer_type() {\r\n    const prefix = consume(\"unsigned\");\r\n    const base = consume(\"short\", \"long\");\r\n    if (base) {\r\n      const postfix = consume(\"long\");\r\n      return new Type({ source, tokens: { prefix, base, postfix } });\r\n    }\r\n    if (prefix) error(\"Failed to parse integer type\");\r\n  }\r\n\r\n  function float_type() {\r\n    const prefix = consume(\"unrestricted\");\r\n    const base = consume(\"float\", \"double\");\r\n    if (base) {\r\n      return new Type({ source, tokens: { prefix, base } });\r\n    }\r\n    if (prefix) error(\"Failed to parse float type\");\r\n  }\r\n\r\n  function primitive_type() {\r\n    const num_type = integer_type() || float_type();\r\n    if (num_type) return num_type;\r\n    const base = consume(\"boolean\", \"byte\", \"octet\");\r\n    if (base) {\r\n      return new Type({ source, tokens: { base } });\r\n    }\r\n  }\r\n\r\n  function type_suffix(obj) {\r\n    const nullable = consume(\"?\");\r\n    if (nullable) {\r\n      obj.tokens.nullable = nullable;\r\n    }\r\n    if (probe(\"?\")) error(\"Can't nullable more than once\");\r\n  }\r\n\r\n  class Type extends Base {\r\n    constructor({ source, tokens }) {\r\n      super({ source, tokens });\r\n      Object.defineProperty(this, \"subtype\", { value: [] });\r\n      this.extAttrs = [];\r\n    }\r\n\r\n    get generic() {\r\n      return \"\";\r\n    }\r\n    get nullable() {\r\n      return !!this.tokens.nullable;\r\n    }\r\n    get union() {\r\n      return false;\r\n    }\r\n    get idlType() {\r\n      if (this.subtype.length) {\r\n        return this.subtype;\r\n      }\r\n      // Adding prefixes/postfixes for \"unrestricted float\", etc.\r\n      const name = [\r\n        this.tokens.prefix,\r\n        this.tokens.base,\r\n        this.tokens.postfix\r\n      ].filter(t => t).map(t => t.value).join(\" \");\r\n      return unescape(name);\r\n    }\r\n  }\r\n\r\n  class GenericType extends Type {\r\n    static parse(typeName) {\r\n      const base = consume(\"FrozenArray\", \"Promise\", \"sequence\", \"record\");\r\n      if (!base) {\r\n        return;\r\n      }\r\n      const ret = new GenericType({ source, tokens: { base } });\r\n      ret.tokens.open = consume(\"<\") || error(`No opening bracket after ${base.type}`);\r\n      switch (base.type) {\r\n        case \"Promise\": {\r\n          if (probe(\"[\")) error(\"Promise type cannot have extended attribute\");\r\n          const subtype = return_type(typeName) || error(\"Missing Promise subtype\");\r\n          ret.subtype.push(subtype);\r\n          break;\r\n        }\r\n        case \"sequence\":\r\n        case \"FrozenArray\": {\r\n          const subtype = type_with_extended_attributes(typeName) || error(`Missing ${base.type} subtype`);\r\n          ret.subtype.push(subtype);\r\n          break;\r\n        }\r\n        case \"record\": {\r\n          if (probe(\"[\")) error(\"Record key cannot have extended attribute\");\r\n          const keyType = consume(...stringTypes) || error(`Record key must be one of: ${stringTypes.join(\", \")}`);\r\n          const keyIdlType = new Type({ source, tokens: { base: keyType }});\r\n          keyIdlType.tokens.separator = consume(\",\") || error(\"Missing comma after record key type\");\r\n          keyIdlType.type = typeName;\r\n          const valueType = type_with_extended_attributes(typeName) || error(\"Error parsing generic type record\");\r\n          ret.subtype.push(keyIdlType, valueType);\r\n          break;\r\n        }\r\n      }\r\n      if (!ret.idlType) error(`Error parsing generic type ${base.type}`);\r\n      ret.tokens.close = consume(\">\") || error(`Missing closing bracket after ${base.type}`);\r\n      return ret;\r\n    }\r\n\r\n    get generic() {\r\n      return this.tokens.base.value;\r\n    }\r\n  }\r\n\r\n  function single_type(typeName) {\r\n    let ret = GenericType.parse(typeName) || primitive_type();\r\n    if (!ret) {\r\n      const base = consume(ID, ...stringTypes);\r\n      if (!base) {\r\n        return;\r\n      }\r\n      ret = new Type({ source, tokens: { base } });\r\n      if (probe(\"<\")) error(`Unsupported generic type ${base.value}`);\r\n    }\r\n    if (ret.generic === \"Promise\" && probe(\"?\")) {\r\n      error(\"Promise type cannot be nullable\");\r\n    }\r\n    ret.type = typeName || null;\r\n    type_suffix(ret);\r\n    if (ret.nullable && ret.idlType === \"any\") error(\"Type `any` cannot be made nullable\");\r\n    return ret;\r\n  }\r\n\r\n  class UnionType extends Type {\r\n    static parse(type) {\r\n      const tokens = {};\r\n      tokens.open = consume(\"(\");\r\n      if (!tokens.open) return;\r\n      const ret = new UnionType({ source, tokens });\r\n      ret.type = type || null;\r\n      while (true) {\r\n        const typ = type_with_extended_attributes() || error(\"No type after open parenthesis or 'or' in union type\");\r\n        if (typ.idlType === \"any\") error(\"Type `any` cannot be included in a union type\");\r\n        ret.subtype.push(typ);\r\n        const or = consume(\"or\");\r\n        if (or) {\r\n          typ.tokens.separator = or;\r\n        }\r\n        else break;\r\n      }\r\n      if (ret.idlType.length < 2) {\r\n        error(\"At least two types are expected in a union type but found less\");\r\n      }\r\n      tokens.close = consume(\")\") || error(\"Unterminated union type\");\r\n      type_suffix(ret);\r\n      return ret;\r\n    }\r\n\r\n    get union() {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function type(typeName) {\r\n    return single_type(typeName) || UnionType.parse(typeName);\r\n  }\r\n\r\n  function type_with_extended_attributes(typeName) {\r\n    const extAttrs = ExtendedAttributes.parse();\r\n    const ret = type(typeName);\r\n    if (ret) ret.extAttrs = extAttrs;\r\n    return ret;\r\n  }\r\n\r\n  class Argument extends Base {\r\n    static parse() {\r\n      const start_position = tokeniser.position;\r\n      const tokens = {};\r\n      const ret = new Argument({ source, tokens });\r\n      ret.extAttrs = ExtendedAttributes.parse();\r\n      tokens.optional = consume(\"optional\");\r\n      ret.idlType = type_with_extended_attributes(\"argument-type\");\r\n      if (!ret.idlType) {\r\n        return unconsume(start_position);\r\n      }\r\n      if (!tokens.optional) {\r\n        tokens.variadic = consume(\"...\");\r\n      }\r\n      tokens.name = consume(ID, ...argumentNameKeywords);\r\n      if (!tokens.name) {\r\n        return unconsume(start_position);\r\n      }\r\n      ret.default = tokens.optional ? Default.parse(tokeniser) : null;\r\n      return ret;\r\n    }\r\n\r\n    get optional() {\r\n      return !!this.tokens.optional;\r\n    }\r\n    get variadic() {\r\n      return !!this.tokens.variadic;\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function argument_list() {\r\n    return list(tokeniser, { parser: Argument.parse, listName: \"arguments list\" });\r\n  }\r\n\r\n  function identifiers() {\r\n    const ids = list(tokeniser, { parser: Token.parser(tokeniser, ID), listName: \"identifier list\" });\r\n    if (!ids.length) {\r\n      error(\"Expected identifiers but none found\");\r\n    }\r\n    return ids;\r\n  }\r\n\r\n  class ExtendedAttributeParameters extends Base {\r\n    static parse() {\r\n      const tokens = { assign: consume(\"=\") };\r\n      const ret = new ExtendedAttributeParameters({ source, tokens });\r\n      if (tokens.assign) {\r\n        tokens.secondaryName = consume(ID, DECIMAL, INT, STR);\r\n      }\r\n      tokens.open = consume(\"(\");\r\n      if (tokens.open) {\r\n        ret.list = ret.rhsType === \"identifier-list\" ?\r\n          // [Exposed=(Window,Worker)]\r\n          identifiers() :\r\n          // [NamedConstructor=Audio(DOMString src)] or [Constructor(DOMString str)]\r\n          argument_list();\r\n        tokens.close = consume(\")\") || error(\"Unexpected token in extended attribute argument list\");\r\n      } else if (ret.hasRhs && !tokens.secondaryName) {\r\n        error(\"No right hand side to extended attribute assignment\");\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    get rhsType() {\r\n      return !this.tokens.assign ? null :\r\n        !this.tokens.secondaryName ? \"identifier-list\" :\r\n        this.tokens.secondaryName.type;\r\n    }\r\n  }\r\n\r\n  class SimpleExtendedAttribute extends Base {\r\n    static parse() {\r\n      const name = consume(ID);\r\n      if (name) {\r\n        return new SimpleExtendedAttribute({\r\n          tokens: { name },\r\n          params: ExtendedAttributeParameters.parse()\r\n        });\r\n      }\r\n    }\r\n\r\n    constructor({ source, tokens, params }) {\r\n      super({ source, tokens });\r\n      Object.defineProperty(this, \"params\", { value: params });\r\n    }\r\n\r\n    get type() {\r\n      return \"extended-attribute\";\r\n    }\r\n    get name() {\r\n      return this.tokens.name.value;\r\n    }\r\n    get rhs() {\r\n      const { rhsType: type, tokens, list } = this.params;\r\n      if (!type) {\r\n        return null;\r\n      }\r\n      const value = type === \"identifier-list\" ? list : tokens.secondaryName.value;\r\n      return { type, value };\r\n    }\r\n    get arguments() {\r\n      const { rhsType, list } = this.params;\r\n      if (!list || rhsType === \"identifier-list\") {\r\n        return [];\r\n      }\r\n      return list;\r\n    }\r\n  }\r\n\r\n  // Note: we parse something simpler than the official syntax. It's all that ever\r\n  // seems to be used\r\n  class ExtendedAttributes extends ArrayBase {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.open = consume(\"[\");\r\n      if (!tokens.open) return [];\r\n      const ret = new ExtendedAttributes({ source, tokens });\r\n      ret.push(...list(tokeniser, {\r\n        parser: SimpleExtendedAttribute.parse,\r\n        listName: \"extended attribute\"\r\n      }));\r\n      tokens.close = consume(\"]\") || error(\"Unexpected form of extended attribute\");\r\n      if (!ret.length) {\r\n        error(\"Found an empty extended attribute\");\r\n      }\r\n      if (probe(\"[\")) {\r\n        error(\"Illegal double extended attribute lists, consider merging them\");\r\n      }\r\n      return ret;\r\n    }\r\n  }\r\n\r\n  class Constant extends Base {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.base = consume(\"const\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      let idlType = primitive_type();\r\n      if (!idlType) {\r\n        const base = consume(ID) || error(\"No type for const\");\r\n        idlType = new Type({ source, tokens: { base } });\r\n      }\r\n      if (probe(\"?\")) {\r\n        error(\"Unexpected nullable constant type\");\r\n      }\r\n      idlType.type = \"const-type\";\r\n      tokens.name = consume(ID) || error(\"No name for const\");\r\n      tokens.assign = consume(\"=\") || error(\"No value assignment for const\");\r\n      tokens.value = const_value(tokeniser) || error(\"No value for const\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated const\");\r\n      const ret = new Constant({ source, tokens });\r\n      ret.idlType = idlType;\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"const\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n    get value() {\r\n      return const_data(this.tokens.value);\r\n    }\r\n  }\r\n\r\n  class CallbackFunction extends Base {\r\n    static parse(base) {\r\n      const tokens = { base };\r\n      const ret = new CallbackFunction({ source, tokens });\r\n      tokens.name = consume(ID) || error(\"No name for callback\");\r\n      tokeniser.current = ret;\r\n      tokens.assign = consume(\"=\") || error(\"No assignment in callback\");\r\n      ret.idlType = return_type() || error(\"Missing return type\");\r\n      tokens.open = consume(\"(\") || error(\"No arguments in callback\");\r\n      ret.arguments = argument_list();\r\n      tokens.close = consume(\")\") || error(\"Unterminated callback\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated callback\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"callback\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function callback() {\r\n    const callback = consume(\"callback\");\r\n    if (!callback) return;\r\n    const tok = consume(\"interface\");\r\n    if (tok) {\r\n      return Interface.parse(tok, { callback });\r\n    }\r\n    return CallbackFunction.parse(callback);\r\n  }\r\n\r\n  class Attribute extends Base {\r\n    static parse({ special, noInherit = false, readonly = false } = {}) {\r\n      const start_position = tokeniser.position;\r\n      const tokens = { special };\r\n      const ret = new Attribute({ source, tokens });\r\n      if (!special && !noInherit) {\r\n        tokens.special = consume(\"inherit\");\r\n      }\r\n      if (ret.special === \"inherit\" && probe(\"readonly\")) {\r\n        error(\"Inherited attributes cannot be read-only\");\r\n      }\r\n      tokens.readonly = consume(\"readonly\");\r\n      if (readonly && !tokens.readonly && probe(\"attribute\")) {\r\n        error(\"Attributes must be readonly in this context\");\r\n      }\r\n      tokens.base = consume(\"attribute\");\r\n      if (!tokens.base) {\r\n        unconsume(start_position);\r\n        return;\r\n      }\r\n      ret.idlType = type_with_extended_attributes(\"attribute-type\") || error(\"No type in attribute\");\r\n      switch (ret.idlType.generic) {\r\n        case \"sequence\":\r\n        case \"record\": error(`Attributes cannot accept ${ret.idlType.generic} types`);\r\n      }\r\n      tokens.name = consume(ID, \"required\") || error(\"No name in attribute\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated attribute\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"attribute\";\r\n    }\r\n    get special() {\r\n      if (!this.tokens.special) {\r\n        return \"\";\r\n      }\r\n      return this.tokens.special.value;\r\n    }\r\n    get readonly() {\r\n      return !!this.tokens.readonly;\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function return_type(typeName) {\r\n    const typ = type(typeName || \"return-type\");\r\n    if (typ) {\r\n      return typ;\r\n    }\r\n    const voidToken = consume(\"void\");\r\n    if (voidToken) {\r\n      const ret = new Type({ source, tokens: { base: voidToken } });\r\n      ret.type = \"return-type\";\r\n      return ret;\r\n    }\r\n  }\r\n\r\n  class Operation extends Base {\r\n    static parse({ special, regular } = {}) {\r\n      const tokens = { special };\r\n      const ret = new Operation({ source, tokens });\r\n      if (special && special.value === \"stringifier\") {\r\n        tokens.termination = consume(\";\");\r\n        if (tokens.termination) {\r\n          ret.arguments = [];\r\n          return ret;\r\n        }\r\n      }\r\n      if (!special && !regular) {\r\n        tokens.special = consume(\"getter\", \"setter\", \"deleter\");\r\n      }\r\n      ret.idlType = return_type() || error(\"Missing return type\");\r\n      tokens.name = consume(ID);\r\n      tokens.open = consume(\"(\") || error(\"Invalid operation\");\r\n      ret.arguments = argument_list();\r\n      tokens.close = consume(\")\") || error(\"Unterminated operation\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated attribute\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"operation\";\r\n    }\r\n    get name() {\r\n      const { name } = this.tokens;\r\n      if (!name) {\r\n        return \"\";\r\n      }\r\n      return unescape(name.value);\r\n    }\r\n    get special() {\r\n      if (!this.tokens.special) {\r\n        return \"\";\r\n      }\r\n      return this.tokens.special.value;\r\n    }\r\n  }\r\n\r\n  function static_member() {\r\n    const special = consume(\"static\");\r\n    if (!special) return;\r\n    const member = Attribute.parse({ special }) ||\r\n      Operation.parse({ special }) ||\r\n      error(\"No body in static member\");\r\n    return member;\r\n  }\r\n\r\n  function stringifier() {\r\n    const special = consume(\"stringifier\");\r\n    if (!special) return;\r\n    const member = Attribute.parse({ special }) ||\r\n      Operation.parse({ special }) ||\r\n      error(\"Unterminated stringifier\");\r\n    return member;\r\n  }\r\n\r\n  class IterableLike extends Base {\r\n    static parse() {\r\n      const start_position = tokeniser.position;\r\n      const tokens = {};\r\n      const ret = new IterableLike({ source, tokens });\r\n      tokens.readonly = consume(\"readonly\");\r\n      tokens.base = tokens.readonly ?\r\n        consume(\"maplike\", \"setlike\") :\r\n        consume(\"iterable\", \"maplike\", \"setlike\");\r\n      if (!tokens.base) {\r\n        unconsume(start_position);\r\n        return;\r\n      }\r\n\r\n      const { type } = ret;\r\n      const secondTypeRequired = type === \"maplike\";\r\n      const secondTypeAllowed = secondTypeRequired || type === \"iterable\";\r\n\r\n      tokens.open = consume(\"<\") || error(`Error parsing ${type} declaration`);\r\n      const first = type_with_extended_attributes() || error(`Error parsing ${type} declaration`);\r\n      ret.idlType = [first];\r\n      if (secondTypeAllowed) {\r\n        first.tokens.separator = consume(\",\");\r\n        if (first.tokens.separator) {\r\n          ret.idlType.push(type_with_extended_attributes());\r\n        }\r\n        else if (secondTypeRequired)\r\n          error(`Missing second type argument in ${type} declaration`);\r\n      }\r\n      tokens.close = consume(\">\") || error(`Unterminated ${type} declaration`);\r\n      tokens.termination = consume(\";\") || error(`Missing semicolon after ${type} declaration`);\r\n\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return this.tokens.base.value;\r\n    }\r\n    get readonly() {\r\n      return !!this.tokens.readonly;\r\n    }\r\n  }\r\n\r\n  function inheritance() {\r\n    const colon = consume(\":\");\r\n    if (!colon) {\r\n      return {};\r\n    }\r\n    const inheritance = consume(ID) || error(\"No type in inheritance\");\r\n    return { colon, inheritance };\r\n  }\r\n\r\n  class Container extends Base {\r\n    static parse(instance, { type, inheritable, allowedMembers }) {\r\n      const { tokens } = instance;\r\n      tokens.name = consume(ID) || error(\"No name for interface\");\r\n      tokeniser.current = instance;\r\n      if (inheritable) {\r\n        Object.assign(tokens, inheritance());\r\n      }\r\n      tokens.open = consume(\"{\") || error(`Bodyless ${type}`);\r\n      instance.members = [];\r\n      while (true) {\r\n        tokens.close = consume(\"}\");\r\n        if (tokens.close) {\r\n          tokens.termination = consume(\";\") || error(`Missing semicolon after ${type}`);\r\n          return instance;\r\n        }\r\n        const ea = ExtendedAttributes.parse();\r\n        let mem;\r\n        for (const [parser, ...args] of allowedMembers) {\r\n          mem = parser(...args);\r\n          if (mem) {\r\n            break;\r\n          }\r\n        }\r\n        if (!mem) {\r\n          error(\"Unknown member\");\r\n        }\r\n        mem.extAttrs = ea;\r\n        instance.members.push(mem);\r\n      }\r\n    }\r\n\r\n    get partial() {\r\n      return !!this.tokens.partial;\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n    get inheritance() {\r\n      if (!this.tokens.inheritance) {\r\n        return null;\r\n      }\r\n      return unescape(this.tokens.inheritance.value);\r\n    }\r\n  }\r\n\r\n  class Interface extends Container {\r\n    static parse(base, { callback = null, partial = null } = {}) {\r\n      const tokens = { callback, partial, base };\r\n      return Container.parse(new Interface({ source, tokens }), {\r\n        type: \"interface\",\r\n        inheritable: !partial,\r\n        allowedMembers: [\r\n          [Constant.parse],\r\n          [static_member],\r\n          [stringifier],\r\n          [IterableLike.parse],\r\n          [Attribute.parse],\r\n          [Operation.parse]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      if (this.tokens.callback) {\r\n        return \"callback interface\";\r\n      }\r\n      return \"interface\";\r\n    }\r\n  }\r\n\r\n  class Mixin extends Container {\r\n    static parse(base, { partial } = {}) {\r\n      const tokens = { partial, base };\r\n      tokens.mixin = consume(\"mixin\");\r\n      if (!tokens.mixin) {\r\n        return;\r\n      }\r\n      return Container.parse(new Mixin({ source, tokens }), {\r\n        type: \"interface mixin\",\r\n        allowedMembers: [\r\n          [Constant.parse],\r\n          [stringifier],\r\n          [Attribute.parse, { noInherit: true }],\r\n          [Operation.parse, { regular: true }]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"interface mixin\";\r\n    }\r\n  }\r\n\r\n  function interface_(opts) {\r\n    const base = consume(\"interface\");\r\n    if (!base) return;\r\n    const ret = Mixin.parse(base, opts) ||\r\n      Interface.parse(base, opts) ||\r\n      error(\"Interface has no proper body\");\r\n    return ret;\r\n  }\r\n\r\n  class Namespace extends Container {\r\n    static parse({ partial } = {}) {\r\n      const tokens = { partial };\r\n      tokens.base = consume(\"namespace\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      return Container.parse(new Namespace({ source, tokens }), {\r\n        type: \"namespace\",\r\n        allowedMembers: [\r\n          [Attribute.parse, { noInherit: true, readonly: true }],\r\n          [Operation.parse, { regular: true }]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"namespace\";\r\n    }\r\n  }\r\n\r\n  function partial() {\r\n    const partial = consume(\"partial\");\r\n    if (!partial) return;\r\n    return Dictionary.parse({ partial }) ||\r\n      interface_({ partial }) ||\r\n      Namespace.parse({ partial }) ||\r\n      error(\"Partial doesn't apply to anything\");\r\n  }\r\n\r\n  class Dictionary extends Container {\r\n    static parse({ partial } = {}) {\r\n      const tokens = { partial };\r\n      tokens.base = consume(\"dictionary\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      return Container.parse(new Dictionary({ source, tokens }), {\r\n        type: \"dictionary\",\r\n        inheritable: !partial,\r\n        allowedMembers: [\r\n          [Field.parse],\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"dictionary\";\r\n    }\r\n  }\r\n\r\n  class Field extends Base {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new Field({ source, tokens });\r\n      ret.extAttrs = ExtendedAttributes.parse();\r\n      tokens.required = consume(\"required\");\r\n      ret.idlType = type_with_extended_attributes(\"dictionary-type\") || error(\"No type for dictionary member\");\r\n      tokens.name = consume(ID) || error(\"No name for dictionary member\");\r\n      ret.default = Default.parse(tokeniser);\r\n      if (tokens.required && ret.default) error(\"Required member must not have a default\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated dictionary member\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"field\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n    get required() {\r\n      return !!this.tokens.required;\r\n    }\r\n  }\r\n\r\n  class Typedef extends Base {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new Typedef({ source, tokens });\r\n      tokens.base = consume(\"typedef\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      ret.idlType = type_with_extended_attributes(\"typedef-type\") || error(\"No type in typedef\");\r\n      tokens.name = consume(ID) || error(\"No name in typedef\");\r\n      tokeniser.current = ret;\r\n      tokens.termination = consume(\";\") || error(\"Unterminated typedef\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"typedef\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function definition() {\r\n    return callback() ||\r\n      interface_() ||\r\n      partial() ||\r\n      Dictionary.parse() ||\r\n      Enum.parse(tokeniser) ||\r\n      Typedef.parse() ||\r\n      Includes.parse(tokeniser) ||\r\n      Namespace.parse();\r\n  }\r\n\r\n  function definitions() {\r\n    if (!source.length) return [];\r\n    const defs = [];\r\n    while (true) {\r\n      const ea = ExtendedAttributes.parse();\r\n      const def = definition();\r\n      if (!def) {\r\n        if (ea.length) error(\"Stray extended attributes\");\r\n        break;\r\n      }\r\n      def.extAttrs = ea;\r\n      defs.push(def);\r\n    }\r\n    const eof = consume(\"eof\");\r\n    if (options.concrete) {\r\n      defs.push(eof);\r\n    }\r\n    return defs;\r\n  }\r\n  const res = definitions();\r\n  if (tokeniser.position < source.length) error(\"Unrecognised tokens\");\r\n  return res;\r\n}\r\n\r\nexport function parse(str, options = {}) {\r\n  const tokeniser = new Tokeniser(str);\r\n  return parseByTokens(tokeniser, options);\r\n}\r\n","\"use strict\";\r\n\r\nfunction noop(arg) {\r\n  return arg;\r\n}\r\n\r\nconst templates = {\r\n  wrap: items => items.join(\"\"),\r\n  trivia: noop,\r\n  name: noop,\r\n  reference: noop,\r\n  type: noop,\r\n  generic: noop,\r\n  inheritance: noop,\r\n  definition: noop,\r\n  extendedAttribute: noop,\r\n  extendedAttributeReference: noop\r\n};\r\n\r\nexport function write(ast, { templates: ts = templates } = {}) {\r\n  ts = Object.assign({}, templates, ts);\r\n\r\n  function reference(raw, { unescaped, context }) {\r\n    if (!unescaped) {\r\n      unescaped = raw.startsWith(\"_\") ? raw.slice(1) : raw;\r\n    }\r\n    return ts.reference(raw, unescaped, context);\r\n  }\r\n\r\n  function token(t, wrapper = noop, ...args) {\r\n    if (!t) {\r\n      return \"\";\r\n    }\r\n    const value = wrapper(t.value, ...args);\r\n    return ts.wrap([ts.trivia(t.trivia), value]);\r\n  }\r\n\r\n  function reference_token(t, context) {\r\n    return token(t, reference, { context });\r\n  }\r\n\r\n  function name_token(t, arg) {\r\n    return token(t, ts.name, arg);\r\n  }\r\n\r\n  function type_body(it) {\r\n    if (it.union || it.generic) {\r\n      return ts.wrap([\r\n        token(it.tokens.base, ts.generic),\r\n        token(it.tokens.open),\r\n        ...it.subtype.map(type),\r\n        token(it.tokens.close)\r\n      ]);\r\n    }\r\n    const firstToken = it.tokens.prefix || it.tokens.base;\r\n    const prefix = it.tokens.prefix ? [\r\n      it.tokens.prefix.value,\r\n      ts.trivia(it.tokens.base.trivia)\r\n    ] : [];\r\n    const ref = reference(ts.wrap([\r\n      ...prefix,\r\n      it.tokens.base.value,\r\n      token(it.tokens.postfix)\r\n    ]), { unescaped: it.idlType, context: it });\r\n    return ts.wrap([ts.trivia(firstToken.trivia), ref]);\r\n  }\r\n  function type(it) {\r\n    return ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      type_body(it),\r\n      token(it.tokens.nullable),\r\n      token(it.tokens.separator)\r\n    ]);\r\n  }\r\n  function default_(def) {\r\n    if (!def) {\r\n      return \"\";\r\n    }\r\n    return ts.wrap([\r\n      token(def.tokens.assign),\r\n      ...def.expression.map(t => token(t))\r\n    ]);\r\n  }\r\n  function argument(arg) {\r\n    return ts.wrap([\r\n      extended_attributes(arg.extAttrs),\r\n      token(arg.tokens.optional),\r\n      ts.type(type(arg.idlType)),\r\n      token(arg.tokens.variadic),\r\n      name_token(arg.tokens.name, { data: arg }),\r\n      default_(arg.default),\r\n      token(arg.tokens.separator)\r\n    ]);\r\n  }\r\n  function identifier(id, context) {\r\n    return ts.wrap([\r\n      reference_token(id.tokens.value, context),\r\n      token(id.tokens.separator)\r\n    ]);\r\n  }\r\n  function make_ext_at(it) {\r\n    const { rhsType } = it.params;\r\n    return ts.wrap([\r\n      ts.trivia(it.tokens.name.trivia),\r\n      ts.extendedAttribute(ts.wrap([\r\n        ts.extendedAttributeReference(it.name),\r\n        token(it.params.tokens.assign),\r\n        reference_token(it.params.tokens.secondaryName, it),\r\n        token(it.params.tokens.open),\r\n        ...!it.params.list ? [] :\r\n          it.params.list.map(\r\n            rhsType === \"identifier-list\" ? id => identifier(id, it) : argument\r\n          ),\r\n        token(it.params.tokens.close)\r\n      ])),\r\n      token(it.tokens.separator)\r\n    ]);\r\n  }\r\n  function extended_attributes(eats) {\r\n    if (!eats.length) return \"\";\r\n    return ts.wrap([\r\n      token(eats.tokens.open),\r\n      ...eats.map(make_ext_at),\r\n      token(eats.tokens.close)\r\n    ]);\r\n  }\r\n\r\n  function operation(it, parent) {\r\n    const body = it.idlType ? [\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it, parent }),\r\n      token(it.tokens.open),\r\n      ts.wrap(it.arguments.map(argument)),\r\n      token(it.tokens.close),\r\n    ] : [];\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.special),\r\n      ...body,\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n\r\n  function attribute(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.special),\r\n      token(it.tokens.readonly),\r\n      token(it.tokens.base),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it, parent }),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n\r\n  function inheritance(inh) {\r\n    if (!inh.tokens.inheritance) {\r\n      return \"\";\r\n    }\r\n    return ts.wrap([\r\n      token(inh.tokens.colon),\r\n      ts.trivia(inh.tokens.inheritance.trivia),\r\n      ts.inheritance(reference(inh.tokens.inheritance.value, { context: inh }))\r\n    ]);\r\n  }\r\n\r\n  function container(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.callback),\r\n      token(it.tokens.partial),\r\n      token(it.tokens.base),\r\n      token(it.tokens.mixin),\r\n      name_token(it.tokens.name, { data: it }),\r\n      inheritance(it),\r\n      token(it.tokens.open),\r\n      iterate(it.members, it),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n\r\n  function field(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.required),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it, parent }),\r\n      default_(it.default),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n  function const_(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it, parent }),\r\n      token(it.tokens.assign),\r\n      token(it.tokens.value),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n  function typedef(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      ts.type(type(it.idlType)),\r\n      name_token(it.tokens.name, { data: it }),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n  function includes(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      reference_token(it.tokens.target, it),\r\n      token(it.tokens.includes),\r\n      reference_token(it.tokens.mixin, it),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n  function callback(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      name_token(it.tokens.name, { data: it }),\r\n      token(it.tokens.assign),\r\n      ts.type(type(it.idlType)),\r\n      token(it.tokens.open),\r\n      ...it.arguments.map(argument),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination),\r\n    ]), { data: it });\r\n  }\r\n  function enum_(it) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.base),\r\n      name_token(it.tokens.name, { data: it }),\r\n      token(it.tokens.open),\r\n      iterate(it.values, it),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination)\r\n    ]), { data: it });\r\n  }\r\n  function enum_value(v, parent) {\r\n    return ts.wrap([\r\n      ts.trivia(v.tokens.value.trivia),\r\n      ts.definition(\r\n        ts.wrap(['\"', ts.name(v.value, { data: v, parent }), '\"']),\r\n        { data: v, parent }\r\n      ),\r\n      token(v.tokens.separator)\r\n    ]);\r\n  }\r\n  function iterable_like(it, parent) {\r\n    return ts.definition(ts.wrap([\r\n      extended_attributes(it.extAttrs),\r\n      token(it.tokens.readonly),\r\n      token(it.tokens.base, ts.generic),\r\n      token(it.tokens.open),\r\n      ts.wrap(it.idlType.map(type)),\r\n      token(it.tokens.close),\r\n      token(it.tokens.termination)\r\n    ]), { data: it, parent });\r\n  }\r\n  function eof(it) {\r\n    return ts.trivia(it.trivia);\r\n  }\r\n\r\n  const table = {\r\n    interface: container,\r\n    \"interface mixin\": container,\r\n    namespace: container,\r\n    operation,\r\n    attribute,\r\n    dictionary: container,\r\n    field,\r\n    const: const_,\r\n    typedef,\r\n    includes,\r\n    callback,\r\n    enum: enum_,\r\n    \"enum-value\": enum_value,\r\n    iterable: iterable_like,\r\n    legacyiterable: iterable_like,\r\n    maplike: iterable_like,\r\n    setlike: iterable_like,\r\n    \"callback interface\": container,\r\n    eof\r\n  };\r\n  function dispatch(it, parent) {\r\n    const dispatcher = table[it.type];\r\n    if (!dispatcher) {\r\n      throw new Error(`Type \"${it.type}\" is unsupported`);\r\n    }\r\n    return table[it.type](it, parent);\r\n  }\r\n  function iterate(things, parent) {\r\n    if (!things) return;\r\n    const results = things.map(thing => dispatch(thing, parent));\r\n    return ts.wrap(results);\r\n  }\r\n  return iterate(ast);\r\n}\r\n","\"use strict\";\r\n\r\nimport { validationError as error } from \"./error.js\";\r\n\r\nfunction groupDefinitions(all) {\r\n  const unique = new Map();\r\n  const duplicates = new Set();\r\n  const partials = new Map();\r\n  for (const def of all) {\r\n    if (def.partial) {\r\n      const array = partials.get(def.name);\r\n      if (array) {\r\n        array.push(def);\r\n      } else {\r\n        partials.set(def.name, [def]);\r\n      }\r\n      continue;\r\n    }\r\n    if (!def.name) {\r\n      continue;\r\n    }\r\n    if (!unique.has(def.name)) {\r\n      unique.set(def.name, def);\r\n    } else {\r\n      duplicates.add(def);\r\n    }\r\n  }\r\n  return { all, unique, partials, duplicates };\r\n}\r\n\r\nfunction* checkDuplicatedNames({ unique, duplicates }) {\r\n  for (const dup of duplicates) {\r\n    const { name } = dup;\r\n    const message = `The name \"${name}\" of type \"${unique.get(name).type}\" was already seen`;\r\n    yield error(dup.source, dup.tokens.name, dup, message);\r\n  }\r\n}\r\n\r\nfunction* checkInterfaceMemberDuplication(defs) {\r\n  const interfaces = [...defs.unique.values()].filter(def => def.type === \"interface\");\r\n  const includesMap = getIncludesMap();\r\n\r\n  for (const i of interfaces) {\r\n    yield* forEachInterface(i);\r\n  }\r\n\r\n  function* forEachInterface(i) {\r\n    const opNames = new Set(getOperations(i).map(op => op.name));\r\n    const partials = defs.partials.get(i.name) || [];\r\n    const mixins = includesMap.get(i.name) || [];\r\n    for (const ext of [...partials, ...mixins]) {\r\n      const additions = getOperations(ext);\r\n      yield* forEachExtension(additions, opNames, ext, i);\r\n      for (const addition of additions) {\r\n        opNames.add(addition.name);\r\n      }\r\n    }\r\n  }\r\n\r\n  function* forEachExtension(additions, existings, ext, base) {\r\n    for (const addition of additions) {\r\n      const { name } = addition;\r\n      if (name && existings.has(name)) {\r\n        const message = `The operation \"${name}\" has already been defined for the base interface \"${base.name}\" either in itself or in a mixin`;\r\n        yield error(ext.source, addition.tokens.name, ext, message);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getOperations(i) {\r\n    return i.members\r\n      .filter(({type}) => type === \"operation\");\r\n  }\r\n\r\n  function getIncludesMap() {\r\n    const map = new Map();\r\n    const includes = defs.all.filter(def => def.type === \"includes\");\r\n    for (const include of includes) {\r\n      const array = map.get(include.target);\r\n      const mixin = defs.unique.get(include.includes);\r\n      if (!mixin) {\r\n        continue;\r\n      }\r\n      if (array) {\r\n        array.push(mixin);\r\n      } else {\r\n        map.set(include.target, [mixin]);\r\n      }\r\n    }\r\n    return map;\r\n  }\r\n}\r\n\r\nexport function validate(ast) {\r\n  const defs = groupDefinitions(ast);\r\n  return [\r\n    ...checkDuplicatedNames(defs),\r\n    ...checkInterfaceMemberDuplication(defs)\r\n  ];\r\n}\r\n","export { parse } from \"./lib/webidl2.js\";\r\nexport { write } from \"./lib/writer.js\";\r\nexport { validate } from \"./lib/validator.js\";\r\n"],"sourceRoot":""}